* Getting the Ball Rolling
** DONE What Do We Build First
   CLOSED: [2018-08-13 Mon 16:53]
   - State "DONE"       from "STARTED"    [2018-08-13 Mon 16:53]
   First of all, welcome to Test-Driven Laravel!
   To get things started, let's talk a bit about the app we are going to build, and figure out where we should start.
   [[~/Documents/tutorials/test-driven-laravel/1-getting-the-ball-rolling/1-what-do-we-build-first.mp4][1-what-do-we-build-first.mp4]]
** DONE Sketching out Our First Test
   CLOSED: [2018-08-13 Mon 17:13]
   - State "DONE"       from "STARTED"    [2018-08-13 Mon 17:13]
   In this lesson, we scaffold out a new application and start sketching out the first test.
   *Important note*
   We start the course with Laravel 5.3 which was the current version at the time of recording. If you want to follow along line-by-line, I recommend that you start with a fresh 5.3 project, and upgrade to 5.4 and beyong we do it in the course.
   To create a fresh Laravel 5.3 project, run this in your terminal.
   =composer create-project laravel/laravel=5.3.* ticketbeast=
   If you'd like to start with Laravel 5.4(or even 5.5), I recommand watching the upgrade videos first so you have an idea of what differences you need to watch out for.


   - Tests
     - =user_can_view_a_concert_listing= in =ViewConcertListing Test=
       - Arrange
         Create a Project
       - Act
         View the concert listing
       - Assert
         See the concert details

** DONE Getting to Green
   CLOSED: [2018-08-13 Mon 17:54]
   - State "DONE"       from "TODO"       [2018-08-13 Mon 17:54]
   In this lesson, we use TDD to scaffold out a lot of the boiler plate in the application and get our first test passing.

   - Summary
     - One test drive one line code.

** DONE Unit Testing Presentation Logic
   CLOSED: [2018-08-14 Tue 12:57]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 12:57]
   In this lesson, we drive out some presentation helpers via unit tests to extract some logic from our view.

   - Tests
     - =can_get_formatted_date= in =ConcertTest= =unit=

   - Summary
     - Use Laravel =factory= to create test data
     - Use =get<item>Attribute= magic method to dynamic get attribute.
** DONE Refactoring For Speed
   CLOSED: [2018-08-14 Tue 16:25]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 16:25]
   In this lesson, we finish extracting some presentation helpers, then refactor our tests to run without using the database to keep thing fast.

   - Tests
     - =can_get_formatted_start_time= in =ConcertTest= =unit=
     - =can_get_ticket_price_in_dollars= in =ConcertTest= =unit=
   - Summary
     - =create= and =make= differences

** DONE Hiding Unpublished Concerts
   CLOSED: [2018-08-14 Tue 16:37]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 16:37]
   In this lesson, we introduce the idea of "published" and "unpublished" concerts, and hide unpblished concerts from visitors to the site.

   - Tests
     - =user_cannot_view_unpublished_concert_listings= in =ViewConcertListingTest= =feature=

   - Summary
     - =published= and =unpublished=
       =publish=true/false= vs =published_at=timestamps/null=
     - =assertResponseStatusCode()=
     - =whereNotNull= eloquent query
     - =get()= vs =visit()= method to get the endpoint in test

** DONE Testing Query Scopes
   CLOSED: [2018-08-14 Tue 16:51]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 16:51]
   In this lesson, we extract some query logic to a custom scope and ensure that it's covered by our tests.

   - Tests
     - change =user_can_view_a_concert_listing= to =user_can_view_a_published_concert_listing=
     - =concerts_with_a_published_at_date_are_published=

   - Summary
     - Encapsulate model query from controller to query scope.

** DONE Factory States
   CLOSED: [2018-08-14 Tue 16:58]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 16:58]
   In this lesson, we abstract some details about makes a concert "published" from our tests by encapsulating them in a factory state.

   - Summary
     - factory state =$factory->state(App\Concert::class, 'published', closure)=

* Purchasing Concert Tickets
** DONE Intro
   CLOSED: [2018-08-14 Tue 17:00]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 17:00]
   In this lesson, we talk about getting started with the "Purchasing Concert Tickets" feature that we're going to implement next.

** DONE Browser Testing vs Endpoint Testing
   CLOSED: [2018-08-14 Tue 17:28]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 17:28]
   In this lesson, we talk about the trade-offs involved in testing through the browser vs. testing endpoint directly, and why you might choose one option over the other.

   - Summary
     - What do I want from my tests?
       1. Confidence that the system works
       2. Reliable, don't break for unimportant reasons.
       3. Fast, so I run them often.
       4. Simple, as few tools as possible, easy to recreate test environment.

** DONE Outlining the First Purchasing Test
   CLOSED: [2018-08-14 Tue 17:39]
   - State "DONE"       from "STARTED"    [2018-08-14 Tue 17:39]
   In this lesson, we design our initial "customer can purchase concert tickets" test.

   - Tests
     - =customer_can_purchase_concert_tickets= in =PurchaseTicketsTest=
   - Summary
     - =$this->json('POST', '/endpoint', [data])= use json to visit an endpoint.
     - Use test as a playground to play with code.

** DONE Faking the Payment Gateway
   CLOSED: [2018-08-15 Wed 12:42]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 12:42]
   In this lesson, we create a fake implementation of our payment gateway to avoid hitting Stripe during our intergration tests.

   - Tests
     - =charges_with_a_valid_payment_token_are_successful= in =FakePaymentGateWayTest= =unit=
   - Summary
     - Down to unit test to implement FakePaymentGateWay methods
     - =$this->app->instance('<interface>', 'instance')= Laravel bind instance to interface.

** DONE Adding Tickets to Orders
   CLOSED: [2018-08-15 Wed 14:12]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 14:12]
   In this lesson, we work on creating tickets and attaching them to orders when a customer make a purchase.

   - Summary
     - Use the =hasMany= snippets
     - Use the =range(1, $quantity)= php method in =foreach= to create the quantily tickets.

** DONE Encapsulating Relationship Logic in the Model
   CLOSED: [2018-08-15 Wed 14:19]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 14:19]
   In this lesson, we work on refactoring some of our controller code and pushing some logic into the model.

   - Tests
     - =can_order_concert_tickets= in =ConcertTest= =unit=

** DONE Getting Started with Validation Testing
   CLOSED: [2018-08-15 Wed 14:29]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 14:29]
   In this lesson, we work on testing and implementing some request validation rules.

   - Tests
     - =email_is_required_to_purchase_tickets= in =PurchaseTicketsTest= =feature=
   - Summary
     - Use =disabledExceptionHandling= to toggle Laravel exception handle.
     - =$this->decodeResponseJson= in test to decode response data to json.

** DONE Reducing Duplication with Custom Assertion
   CLOSED: [2018-08-15 Wed 14:42]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 14:42]
   In this lesson, we abstract some commonly paired assertions behind a custom assertion with a more expressive name.

   - Summary
     - Encapsulate the post method and parameters to a dedicated method
     - Encapsulate validation assert to a dedicated method =assertValidationError=

** DONE Handling Failed Charges
   CLOSED: [2018-08-15 Wed 14:53]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 14:53]
   In this lesson, we drive out what should happen when a customer's payment fails.

   - Tests
     - =an_order_is_not_created_if_payment_fails= in =PurchaseTicketsTest= =feature=
     - =charges_with_an_invalid_payment_token_fail= in =FakePaymentGateWayTest= =unit=
   - Summary
     - Use =try-catch= block in the tests for having change to handling the exception

** DONE Preventing Tickets Sales to Unpublished Concerts
   CLOSED: [2018-08-15 Wed 15:04]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 15:04]
   In this lesson, we add a new feature test to cover the situation when someone tries to view a concert that hasn't been published yet.

   - Tests
     - =cannot_purchase_tickets_to_an_unpublished_concert= in =PurchaseTicketsTest= =feature=
     - change =customer_can_purchase_concert_tickets= to =customer_can_purchase_to_a_published_concert=
   - Summary
     - =findOrFail= convert to 404 exception

* Limiting Tickets Sales

** DONE Outlining the First Test Case
   CLOSED: [2018-08-15 Wed 15:18]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 15:18]
   In this lesson, we work on writing a test to ensure that customers can't purchase more tickets than are still available

   - Tests
     - =cannot_purchase_more_tickets_than_remain= in =PurchaseTicketsTest= =feature=
** DONE Adding Tickets to Concerts
   CLOSED: [2018-08-15 Wed 15:30]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 15:30]
   In this lesson, we implement the ability to add tickets to concerts so there are tickets available when a customer tries to purchase.

   - Tests
     - =can_add_tickets= in =ConcertTest= =unit=
     - =tickets_remaining_does_not_include_tickets_associated_with_an_order= in =ConcertTest= =unit=

** DONE Refusing Orders When There Are No More Tickets
   CLOSED: [2018-08-15 Wed 15:48]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 15:48]
   In this lesson, we work on making sure orders are not created when someone tries to purchase more tickets than remain, and ensuring that a customer can't purchase tickets already purchased by another customer.

   - Tests
     - =trying_to_purchase_more_tickets_than_remain_throws_an_exception= in =ConcertTest= =unit=
     - =cannot_order_tickets_that_have_already_been_purchasedA in =ConcertTest== =unit=
   - Summary
     - =$this->fail('message')= in the =fail= method add the failed message.

** DONE Finish the Feature Test
   CLOSED: [2018-08-15 Wed 15:54]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 15:54]
   In this lesson, we get our "cannot purchase more tickets than remain" feature test passing by finishing our controller implementation.

** DONE Cancelling Failed Orders
   CLOSED: [2018-08-15 Wed 16:03]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 16:03]
   In this lesson, we make sure that if a customer's payment fails, we cancel their order.

   - Tests
     - =tickets_are_released_when_order_is_cancelled= in =OrderTest= =unit=
   - Summary
     - assert status in arrange state.

** DONE Refactoring and Redundant Test Coverage
   CLOSED: [2018-08-15 Wed 16:18]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 16:18]
   In this lesson, we extract some logic from our Order class to Tickets class, and discuss whether or not it's important to add new test coverage.

   - Tests
     - =a_ticket_can_be_released= in =TicketsTest= =unit=
   - Summary
     - =fresh()= method in tests

** DONE Cleaning Up Our Tests
   CLOSED: [2018-08-15 Wed 16:34]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 16:34]
   Much like production code, test code needs to be refactored and kept healthy and maintainable.
   In this lesson, we go over our existing test suite and look for opportunities to clean it up.

   - Summary
     - Compasered =assertConcertHasOrderFor($concert, 'email')=, =assertConcertDoesNotHaveOrderFor= with =assertTrue($concert->hasOrderFor('email'))=
     - =hasOrderFor= method near the =order= relaction method

* Returning Order Details
** DONE Asserting Against JSON Response
   CLOSED: [2018-08-15 Wed 16:52]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 16:52]
  In this lesson, we add tests to ensure that we are getting back meaniningfully order information after purchasing tickets, and discuss different strategies for testing JSON response.

  - Summary
    - =seeJsonEquals= match the expected results exactly with response.
    - =seeJsonContains/seeJson= response contain the expected results, especially contain the deep layer data.
    - =seeJsonSubset= only check the subset contain the expected results. it is a magical method. 🔥
** DONE Returning Order Details
   CLOSED: [2018-08-15 Wed 17:01]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 17:01]
   In this lesson, we work on getting our existing feature test passing by driving out an order's JSON representation at the unit level.

   - Tests
     - =converting_to_an_array= in =OrderTest= =unit=

** DONE This Design Sucks
   CLOSED: [2018-08-15 Wed 17:07]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 17:07]
   You don't awlays write beautiful code on the first try.
   In this lesson, we talks about three issues with our existing design and why they are worth addressing.

* A Surgical Refactoring
** DONE Persisting the Order Amount
   CLOSED: [2018-08-15 Wed 17:19]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 17:19]
  In this lesson, we work on persisting the order amount to the database, instead of calculating it on the fly based on tickets price and tickets quantity.

  - Summary
    - When refactor, keep test green and add code and comment it.

** DONE Removing the Need to Cancel Orders
   CLOSED: [2018-08-15 Wed 17:27]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 17:27]
   In this lesson, we work getting rid of the need to cancel orders when a payment fails by separating the idea of finding tickets from confirming an order.

** DONE Preparing for Extraction
   CLOSED: [2018-08-15 Wed 17:36]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 17:36]
   In this lesson, we work on removing the need to create orders through a concert by removing a redundant relationship.

   - Summary
     - When refactor, keep tests green!

** DONE Extracting a Named Constructor
   CLOSED: [2018-08-15 Wed 17:50]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 17:50]
   In this lesson, we introduced a named constructor for creating orders from customer details and tickets.

   - Tests
     - =creating_an_order_from_tickets_and_email= in =OrderTest= =unit=

** DONE Precomputing the Order Amount
   CLOSED: [2018-08-15 Wed 17:59]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 17:59]
   In this lesson, we work on removing the need for an order to know how to calculate it's own price so we can eliminlate some duplication in our code.

   - Tests
     - change =creating_an_order_from_tickets_and_email= to =creating_an_order_from_tickets_email_and_amount= in =OrderTest= =unit=

** DONE Uncovering a New Domain Object
   CLOSED: [2018-08-15 Wed 18:06]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 18:06]
   In this lesson, we walk through a strategy I use to discover new objects in my code, and start driving out a new domain object with tests.

   - Tests
     - =calculating_the_total_cost= in =ReservationTest= =unit=

** DONE You Might Not Need a Mocking Framework
   CLOSED: [2018-08-15 Wed 18:12]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 18:12]
   In this lesson, we work on removing the need to migrate the database when testing our simple Reservation class.
   We also talk about different approaches to isolating the Reservation from it's collaborators, and why you might not need a special library to do it.

* Off to the Races
** DONE Uh Oh, a Race Condition!
   CLOSED: [2018-08-15 Wed 20:10]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 20:10]
   Over the last few lessons we've improved the design of our code significantly, but we've also introduced a race condition.

** DONE Requestception
   CLOSED: [2018-08-15 Wed 20:18]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 20:18]
   In this lesson, we discuss how subrequests work, and how we can use them to help test this race condition.

   - Tests
     - =cannot_purchase_tickets_another_customer_is_trying_to_purchase= in =PurchaseTicketsTest= =feature=
   - Summary
     - subrequest test

** DONE Hooking into Charges
   CLOSED: [2018-08-15 Wed 20:27]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 20:27]
   In this lesson, we add a hook to our fake payment gateway to allow us to trigger a nested request.

   - Tests
     - =runnig_a_hook_before_the_first_charge= in =FakePaymentGateWayTest= =unit=
   - Summary
     - Use hook and callback in the =FakePaymentGateWay= to trigger before charge functions
     - =$this->beforeFirstChargeCallback->__invoke($this)= use this to invoke callback attribute.

** DONE Uh Oh, a Segfault!
   CLOSED: [2018-08-15 Wed 20:33]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 20:33]
   In this lesson, we finish wrting our feature test to cover the race condition. But when we run it, we hit a segfault! Let's see if we can diagnose the issue.

   - Summary
     - =segmentation fault= in phpunit, maybe infinite loop.

** DONE Replicating the Failure at the Unit Level
   CLOSED: [2018-08-15 Wed 20:39]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 20:39]
   In order to get a better understanding of our segfault issue, we try and replicate it at the unit level so we can fix it more easily.

** DONE Reserving Individual Tickets
   CLOSED: [2018-08-15 Wed 20:55]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 20:55]
   To make sure nobody can purchase someone else's tickets while they are still trying to pay, we work on introducing the idea of a ticket being "reserved".

   - Tests
     - =a_ticket_can_be_reserved= in =TicketTest= =unit=
   - Summary
     - In factory use closure =function() { factory(); }= to delay factory.

** DONE Reserved Means Reserved
   CLOSED: [2018-08-15 Wed 21:01]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 21:01]
   In this lesson, we work on making sure the rest of the application respects our newly introduced "reserved" status on tickets.

   - Tests
     - =cannot_reserved_tickets_that_have_already_been_purchased= in =ConcertTest= =unit=
     - =cannot_reserved_tickets_that_have_already_been_reserved= in =ConcertTest= =unit=

** DONE That Guy Stole My Tickets
   CLOSED: [2018-08-15 Wed 21:09]
   - State "DONE"       from "STARTED"    [2018-08-15 Wed 21:09]
   For some reason, person B is getting their name added to tickets that person A paid for! Let's figure out what's going on.

   - Summary
     - Laravel only maintain a request information. If test have subrequest, the first request will replaced by last request even last request is finished.
       The solution is save the first request and restore the saved request after last request is finished. =$savedRequest = $this->app['request']= and =$this->app['request'] = $savedRequest=

* Hunting for Stale Code

** DONE Cancelling Reservation
   CLOSED: [2018-08-16 Thu 04:31]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 04:31]
   In this lesson, we find a sneaky bug and work towards solving it through an isolated unit test.

   - Tests
     - =reserved_tickets_are_released_when_a_reservation_is_cancelled= in =ReservationTest= =unit=
   - Summary
     - use Mockery to assert method should be invoked
       #+BEGIN_SRC php
         $ticket1 = Mockery::mock(Ticket::class);
         $ticket1->shoudlReceive('release')->once();
       #+END_SRC

** DONE Refactoring Mockes to Spies
   CLOSED: [2018-08-16 Thu 04:42]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 04:42]
   In this lesson, we talk about 3 different ways to create mock objects, as well as how using spies instead of mocks can help keep your tests more organized.

   - Summary
     - Mock function the second parameter is a callback
       #+BEGIN_SRC php
         Mock::(Ticket::class, function($mock) {
             $mock->shouldReceive('release')->once();
         })
       #+END_SRC
     - =Mock::mock(Ticket::class)->shouldReceive('release')->getMock()= method to get mock
     - Mockery spy
       #+BEGIN_SRC php
         // Arrange
         $ticket = Mockery::spy(Ticket::class);

         // Assert
         $ticket->shouldHaveReceived('release');
       #+END_SRC

** DONE A Change in Behavior
   CLOSED: [2018-08-16 Thu 04:51]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 04:51]
   Our feature test is still failing because some of our older code has a different understanding of what it means to "releases" tickets.
   In this lesson, we diagnose the issue and update our specification to help us drive out the change in behavior.

   - Summary
     - =release= and =reserved= are different meanings in the code.

** DONE Deleting Stale Tests
   CLOSED: [2018-08-16 Thu 05:10]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 05:10]
   In this lesson, we discuss the importance of high level feature tests, and how they help give use the confidence to delete stale code when confronted with a failing unit test.

   - Summary
     - =Feature= test is our application feature, and =Unit= test is to help Feature test.
     - When delete stale code, first thing is run the feature test to improve the feature test is passing. And then comment the stale code and rerun feature test, if also passing, we can confidence to delete that code. And last thing, inspect the method in the code, and comment the method rerun feature test to check is still passing, if so, delete it.

* Something Smells in Our Controllers
** DONE Cleaning Up a Loose Variable
   CLOSED: [2018-08-16 Thu 05:21]
   - State "DONE"       from              [2018-08-16 Thu 05:21]
   In this lesson, we look to eliminate a loose variable in our controller by adding some additional behavior to our Reservation class, and then spend some time pushing the responsibility for creating reservations inside our Concert class and out of our controller.

   - Tests
     - =retrieving_the_reservation_tickets= in =ReservationTest= =unit=
   - Summary
     - When refactor, eliminate loose variables is a way.

** DONE Moving the Email to Reservation
   CLOSED: [2018-08-16 Thu 05:32]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 05:32]
   In this lesson, we notice a long parameter list we'd like to refactor, but in order to do that, we need to tweak how reservations are created so that reservation has knowledge of the customer who is reserving the tickets.

   - Tests
     - =retrieving_the_customers_email= in =ReservationTest= =unit=
   - Summary
     - Encapsulate the email responsibility to the Reservation class.
     - Consistence the parameters to easily refactor the responsibility to some class.

** DONE Refactoring "Long Parameters List" Using "Preserve Whole Object"
   CLOSED: [2018-08-16 Thu 08:04]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 08:04]
   In this lesson, we attempt to refactor the "long parameter list" code smell we noticed in our Order class using the "preserve whole object" refactoring.

   - Tests
     - =creating_an_order_from_reservation= in =OrderTest= =unit=
   - Summary
     - [[https://sourcemaking.com/refactoring/smells/long-parameter-list][Long Parameter List]] code smell
     - [[https://sourcemaking.com/refactoring/preserve-whole-object][Preserve Whole Object]] refactoring

** DONE Green with Feature Envy
   CLOSED: [2018-08-16 Thu 08:15]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 08:15]
   Our "preserve whole object" refactoring didn't turn out as nicely as we hoped.
   In this lesson, we look to treat the original problem as a "feature envy" issue instead of a "long parameter list" issue, and see if that leads us to a better solution.

   - Tests
     - =completing_a_reservation= in =ReservationTest= =unit=
   - Summary
     - [[https://sourcemaking.com/refactoring/smells/feature-envy][Feature Envy]] code smell
     - When delete code and tests, first delete code and then delete tests, and last things is run all tests.

** DONE Avoiding Service Classes with Method Injection
   CLOSED: [2018-08-16 Thu 09:07]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 09:07]
   In this lesson, we notice that we're lacking a single source of truth for the amount we charge the customer and the amount used to create the new order.
   We walk through what it might look like to solve this problem with a service class, and then how we can avoid the service class entirely using method injection.

* Testing-Driving the Real Stripe Adapter

** DONE Generating a Valid Payment Token
   CLOSED: [2018-08-16 Thu 09:20]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 09:20]
   In this lesson we scaffold out an initial test for our StripePaymentGateway and figure out how to generate a valid payment token using Stripe's API.

   - Tests
     - =charges_with_a_valid_payment_token_are_successful= in =StripePaymentGatewayTest= =unit=

** DONE Retriving the Last Charge
   CLOSED: [2018-08-16 Thu 09:31]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 09:31]
   In this lesson we use Stripe's API to fetch the most recent charge so we can make assertions about it in our test.

** DONE Making a Successful Charge
   CLOSED: [2018-08-16 Thu 09:38]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 09:38]
   In this lesson we work through the first set of test failures and successfully make a charge to Stripe.

** DONE Dealing with Lingering State
   CLOSED: [2018-08-16 Thu 09:55]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 09:55]
   In this lesson we diagnose why are test is passing after commenting out our implementation, and come up with a new strategy to run our tests with isolated data.

** DONE Don't Mock What You Don't Own
   CLOSED: [2018-08-16 Thu 11:02]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 11:02]
   A commpon miscoception about testing is that you should mock calls to external APIs to avoid the newwork.
   In this lesson, we compare the pros and cons of intergrating with Stripe vs. mocking our calls to Stripe to better understand why shouldn't mock third-party code.

** DONE Using Groups to Skip Intergration Tests
   CLOSED: [2018-08-16 Thu 11:26]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 11:26]
   In this lesson, we use PHPUnit's "group" feature to make it easy to skip our intergration tests when we don't have an internet connection.

   - Summary
     - =phpunit --exclude-group <group-name>= exclude group

** DONE Handling Invalid Payment Tokens
   CLOSED: [2018-08-16 Thu 11:32]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 11:32]
   In this lesson, we add a new test to make sure our StripePaymentGateway behaves as expected when attempting to charge with an invalid payment token.

** DONE The Moment of Truth
   CLOSED: [2018-08-16 Thu 11:38]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 11:38]
   In this lesson, we finally fire up the browser to find out if all of this TDD stuff has really given us a working system.

* Keeping Things Synchronized with Contract Tests

** DONE When Interfaces Aren't Enough
   CLOSED: [2018-08-16 Thu 12:36]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 12:36]
   In this lesson, we identify some of the risks of using fakes, and why it takes more than an interface to make sure multiple implementations stay in sync.

   - Summary
     - Interfaces define the method, not the behavior. The behavior is defined by the tests.
     - ContractTests

** DONE Refactoring Forward Duplication
   CLOSED: [2018-08-16 Thu 12:51]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 12:51]
   In this lesson, we begin refactoring the tests for our two PaymentGateway implementations towards being identical so we can extract them to a contract test.

   - Summary
     - use *closure* to encapsulate method.

** DONE Capturing Charges with Callbacks
   CLOSED: [2018-08-16 Thu 13:59]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 13:59]
   In this lesson, we come up with a strategies for being able to keep track of the total charges made during a test that will work for both implementations for our PaymentGateway interface.

** DONE Making the Tests Identical
   CLOSED: [2018-08-16 Thu 14:09]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 14:09]
   In this lesson, we port the =newChargesDuring= method over to the FakePaymentGateways, finally leaving us with two identical tests that are ready for extraction.

** DONE Extracting a Contract Test
   CLOSED: [2018-08-16 Thu 14:38]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 14:38]
   In this lesson, we extract the identical PaymentGateway tests into a contract test, shared through a trait.

   - Summary
     - Trait with abstract

** DONE Extracting the Failure Case
   CLOSED: [2018-08-16 Thu 14:49]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 14:49]
   In this lesson, we refactor the =charges_with_an_invalid_payment_token_fail= tests to make them identical, and then extract it to our contract tests.

   - Summary
     - Move =try-catch= block to =newChargeDuring= method callback



* Upgrading Our Suit to Laravel 5.4

** DONE Upgrading to Laravel 5.4
   CLOSED: [2018-08-16 Thu 14:56]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 14:56]
   In this lesson, we upgrade TicketBeast to Laravel 5.4, and get our tests back to green using =browser-kit-testing= package.

** DONE Removing the BrowserKit Dependency
   CLOSED: [2018-08-16 Thu 15:21]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 15:21]
   In this lesson, we refactor our BrowserKit tests to use Laravel 5.4's testing features, so we can remove our dependency on the compabitility package.

   - Summary
     - =see= => =$response->assertSee()= in =TestResponse=
     - =seeJsonSubset= => =$response->assertJson()= in =TestResponse=
     - =decodeResponseJson= => =$response->decodeResponseJson=

* Viewing Order Confirmations

** DONE Sketching out Order Confirmations
   CLOSED: [2018-08-16 Thu 15:32]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 15:32]
  In this lesson, we begin driving out our test for viewing order confirmations based on a static mockup.

  - Tests
    - =user_can_view_their_order_confirmation= in =ViewOrderTest= =unit=

** DONE Driving out the Endpoint
   CLOSED: [2018-08-16 Thu 15:54]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 15:54]
   In this lesson, we figure out th URL structure we want to use to keep order confirmation pages private, and drive out the ability to successfully hit out new endpoint.

** DONE Asserting Against View Data
   CLOSED: [2018-08-16 Thu 16:02]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 16:02]
   In this lesson, we flesh out an initial implementation of our controller, and walk through how to test the data that is bound to a view without asserting against the rendered HTML.

   - Summary
     - =$response->assertViewHas('order', $order)=, compare view has object order equals the given order. Even, the second argument can pass a closure and return boolean to tell the assert true or false.

** DONE Extracting a Finder Method
   CLOSED: [2018-08-16 Thu 16:13]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 16:13]
   In this lesson, we refactor some Eloquent calls in our controller to a dedicated finder method, and discuss when it's important to add new tests while refactoring and when it's not.

   - Tests
     - =retrieving_an_order_by_confirmation_number= in =OrderTest= =unit=
     - =retrieving_a_nonexistent_order_by_confirmation_number_throws_an_exception= in =OrderTest= =unit=

** DONE Making Static Data Real
   CLOSED: [2018-08-16 Thu 16:30]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 16:30]
   In this lesson, we work through using tests to replace some of the hard coded data in our mockup with real data that's attached to our order.

** DONE Deciding What to Test in a View
   CLOSED: [2018-08-16 Thu 16:40]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 16:40]
   In this lesson, we spend some time discussing what you need to take into consideration when deciding what data is important to test in a renderd view.

** DONE Decoupling Data from Presentation
   CLOSED: [2018-08-16 Thu 16:55]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 16:55]
   In this lesson, we talk about strategies you can use to make your feature tests more resilient to superficial changes in your templates, and work through a specific example using dates.

   - Summary
     - Use =time= tag, and pass the assert date attribute.

* Generating Confirmation Numbers

** DONE Fixing the Test Suit
   CLOSED: [2018-08-16 Thu 17:05]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 17:05]
   In this lesson, we get our test suit back to green by temporarily making some of our new columns nullable, and discuss adding a test to ensure confirmation numbers are generated for new orders.


   - Summary
     - =phpunit --stop-on-failure= phpunit stop on the first failure
     - =$orderConfirmation->generate()=

** DONE Stubbling the Interface
   CLOSED: [2018-08-16 Thu 17:14]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 17:14]
   In this lesson, we decide we want to able to stub how order confirmation numbers are gerenated for our high level feature test, and use that insight to design an interface where we can encapsulate that logic.

   - Summary
     - Mock =$orderConfirmation->generate()= method, and bind it to the Container.

** DONE Updating Our Unit Tests
   CLOSED: [2018-08-16 Thu 17:28]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 17:28]
   In this lesson, we update one of our =Order= unit tests to make use of the factory we added previously, and make sure that orders include their confirmation numbers when we render them as JSON.

** DONE Confirmation Number Characteristics
   CLOSED: [2018-08-16 Thu 17:35]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 17:35]
   In this lesson, we discuss the what we want our confirmation numbers ultimately look like and why.

** DONE Testing the Confirmation Number Format
   CLOSED: [2018-08-16 Thu 17:47]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 17:47]
   In this lesson, we use the characteristics we identified previously to specify how our confirmation numbers should look with a set of unit tests, and work on getting them to pass.

   - Tests
     - =must_be_24_characters_long= in =RandomOrderConfirmationNumberGeneratorTest= =unit=
     - =can_only_contain_uppercase_letters_and_numbers= in =RandomOrderConfirmationNumberGeneratorTest= =unit=
     - =cannot_contain_ambiguous_characters= in =RandomOrderConfirmationNumberGeneratorTest= =unit=
   - Summary
     - =assertRegExp=

** DONE Ensuring Uniqueness
   CLOSED: [2018-08-16 Thu 17:58]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 17:58]
   In this lesson, we come up with a strategy to force ourselves away from our slimed implementation by testing that each confirmation number is unique.

   - Tests
     - =confirmation_numbers_must_be_unique= in =RandomOrderConfirmationNumberGener= =unit=
   - Summary
     =Str::random= and =Str::quickRandom=

** DONE Refatoring to a Facade
   CLOSED: [2018-08-16 Thu 18:07]
   - State "DONE"       from "STARTED"    [2018-08-16 Thu 18:07]
   In this lesson, we wire up our =RandomOrderConfirmationNumberGenernator= to be the default implementation we use in our application, and make use of Laravel's =Facade= to replace our explict use of Laravel's container in our =order= class with something more expressive.

   - Summary
     - Facade =getFacadeAccessor= and implement Laravel Facade method.

* Storing the Last Four Card Digists

** DONE Prompting Charges to Objects
   CLOSED: [2018-08-17 Fri 02:45]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 02:45]
   In this lesson, we introduce a new =Charge= object to carry meta data about purchases, such as the last four digits of the card used. We drive out this charge in our =FakePaymentGateway= first through changes to our =PaymentGatewayContractTests=.

   - Tests
     - =can_get_detail_about_a_successful_charge= in =PaymentGatewayContractTests= =unit=
   - Summary
     Use tests drive out an object.

** DONE Leveraging Our Contract Tests
   CLOSED: [2018-08-17 Fri 09:11]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 09:11]
   In this lesson, we use our updated contract tests to update the behavior of our =StripePaymentGateway= to keep it synchronized with our fake.

   - Summary
     - php7 parameter can be set by default const.

** DONE Storing Charge Details with Orders
   CLOSED: [2018-08-17 Fri 09:23]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 09:23]
   In this lesson, we update our =OrderTest= to account for creating orders using =Charges= instead of plain amounts, and use that test to drive out the implementation in =order=.
   - Tests
     - change =creating_an_order_from_tickets_email_and_amount= to =creating_an_order_from_tickets_email_and_charge= in =OrderTest= =unit=
   - Summary
     - Feature test should be do reaction during the refactor stage.

** DONE Deleting More Stale Code
   CLOSED: [2018-08-17 Fri 09:44]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 09:44]
   In this lesson, we notice that changing how =orders= created reveals some lingering old design decisions that are triggering test failures. We work through removing the stale code, and updating any tests we need to keep to no longer rely on the code we want to remove.

   - Summary
     - When delete stale code, comment code, and run all tests, if all passing, then should delete it.


* Assigining Ticket Codes

** DONE Feature Test and JSON Updates
   CLOSED: [2018-08-17 Fri 10:03]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 10:03]
   In this lesson, we come up with approach for driving out the generation of ticket codes from the outside in, and make some tweaks to the JSON representation of a completed order.

   - Summary
     - Facade Test
       #+BEGIN_SRC php
         $orderConfirmationNumberGenerator = Mockery::mock(OrderConfirmationNumberGenerator::class, [
             'generate' => 'ORDERCONFIRMATION1234',
         ]);
         $this->app->instance(OrderConfirmationNumberGenerator::class, $OrderConfirmationNumberGenerator);

         // Equals
         OrderConfirmationNumberGenerator::shouldReceive('generate')->andReturn('ODERCONFIRMATION1234');
       #+END_SRC
     - Collection to Array use =all()= method
** DONE Claiming Tickets When Creating Orders
   CLOSED: [2018-08-17 Fri 10:14]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 10:14]
   In this lesson, we decide when ticket codes should be generated, and rework and existing test to use mock expectations to prepare for our implementation.

   - Summary
     - Mockery spy expect method with parameters
       - Mock::spy(Ticker::class)->shouldHaveReceived('claimedFor', ['order']);

** DONE Assigining Codes When Claiming Tickets
   CLOSED: [2018-08-17 Fri 10:35]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 10:35]
   In this lesson, we add a new test for the new =claimFor= method in our =Ticket= class, and drive out them implementation.

   - Tests
     - =a_ticket_can_be_claimed_for_an_order= in =TicketTest= =unit=
   - Summary
     - Facade override =getMockClass=, when report the instantiate errors.

** DONE The Birthday Problem
   CLOSED: [2018-08-17 Fri 10:50]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 10:50]
   In this lesson, we talk about the birthday problem and the implications it has own how we generate ticket codes.
   We also play with the Hashids library to get an understanding of how we could use it to encode ticket IDs.

   - Summary
     - Birthday Problem
     - HashId Library.

** DONE Intergrating Hashids
   CLOSED: [2018-08-17 Fri 11:12]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 11:12]
   In this lesson, we drive out our =HashidsTicketCodeGenerator=, making sure that ticket codes are generated in the format we expect.

   - Tests
     - =ticket_codes_are_at_least_6_character_long= in =HashidsTicketCodeGeneratorTest= =unit=
     - =ticket_codes_can_only_contain_uppercase_letters= in =HashidsTicketCodeGeneratorTest= =unit=
     - =ticket_codes_for_the_same_ticket_id_are_the_same= in =HashidsTicketCodeGeneratorTest= =unit=
     - =ticket_codes_for_different_tickets_are_different= in =HashidsTicketCodeGeneratorTest= =unit=
     - =ticket_codes_generated_with_different_salts_are_different= in =HashidsTicketCodeGeneratorTest= =unit=
   - Summary
     - In test ticket unique stage import the =Hashids= Library.

** DONE Dealing with Out of Sync Mock
   CLOSED: [2018-08-17 Fri 11:20]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 11:20]
   Uh oh! One of our expectations is no longer in sync with the real implementation.
   In this lesson, we use an underappreciated Mockery feature to detect broken mockes, and get things working properly again.

   - Summary
     - =Mockery::getConfiguration()->allowMockeryNonExistentMethods(false)=, use when make some change in the interface.

** DONE Writing It Together
   CLOSED: [2018-08-17 Fri 11:27]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 11:27]
   In this lesson, we bubble back up to our initial feature test and try to get it passing.
   We cover how to return multiple values from a Mockery stub, and wire up our real =HashidsTicketCodeGenerator= in the IOC container to get the test suit back to green.

   - Summary
     Mockery return arrays =Mockery::mock(TicketCodeGenerator::class)->shouldReceive('generatorFor')->andReturn('ticketcode1', 'ticketcode2', 'ticketcode3')=

** DONE Ready to Demo
   CLOSED: [2018-08-17 Fri 11:33]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 11:33]
   In this short lesson, we make a small tweak to our =TicketCheckout= Vue component and finally walk through the entire purchasing flow from start to finish.

* Emailing Order Confirmations

** DONE Using a Fake to Intercept Email
   CLOSED: [2018-08-17 Fri 12:45]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 12:45]
  In this lesson, we use Laravel's =Mail Fake= to test sending an order confirmation email whenever someone purchases tickets.

  - Summary
    - =Mail::fake()= and =Mail::assertSent()=
    - =Mail::send()= send mail
    - test Mail
      #+BEGIN_SRC php
        Mail::assertSent(OrderConfirmationEmail::class, function ($mail) use ($orderId){
            reurn $mail->hasTo('john@example.com')
                && $mail->orderId == $order->id;
        });
      #+END_SRC

** DONE Testing Mailable Contents
   CLOSED: [2018-08-17 Fri 12:59]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 12:59]
   In this lesson, we come up with a way to render mailables as HTML so we can assert against their content.

   - Tests
     - =email_contains_a_link_to_the_order_confirmation_page= in =OrderConfirmationEmailTest= =unit=
     - =email_has_a_subject= in =OrderConfirmationEmailTest= =unit=
   - Summary
     Render Email functions
     #+BEGIN_SRC php
       // Laravel 5.4
       private function render($mailable)
       {
           $mailable->build();
           return view($mailable->view, $mailable->buildViewData())->render();
       }

       // Laravel 5.5 contain the =render= function
     #+END_SRC

** DONE Cleanup and Demo
   CLOSED: [2018-08-17 Fri 13:40]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 13:40]
   In this lesson, we configure Mailtrap so we can test our order confirmation email flow in the browser.

   - Summary
     - Move =Mail::fake()= in the =setUp= method

* Logging in with Dusk

** DONE Testing the Login Endpoint
   CLOSED: [2018-08-17 Fri 13:57]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 13:57]
   The next thing we'd like to build is the ability for promoters to add new concerts, but before we can do that, we need to give them a way to log in to the application.
   In this lesson, we drive out our initial =/login= endpoint.

   - Tests
     - =logging_in_with_valid_credentials= in =PromoterLoginTest= =feature=
     - =logging_in_with_invalid_credentials= in =PromoterLoginTest= =feature=
     - =logging_in_with_an_account_that_does_not_exist= in =PromoterLoginTest= =feature=
   - Summary
     - =Auth::check()=, =Auth::user()->id=, =Auth::attempt()= Auth Facade method.

** DONE Should You TDD Simple Templates?
   CLOSED: [2018-08-17 Fri 14:09]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 14:09]
   In the last lesson we drove out the login endpoint, but we still don't have an actual login form.
   Is this something we should try to build with TDD, or is there a better approach?

   - Tests
     - =showing_the_login_form= in =PromoterLoginTest= =unit=
   - Summary
     Pure HTML page not valuable to use TDD drove out.

** DONE Namespacing Our Test Suite
   CLOSED: [2018-08-17 Fri 14:18]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 14:18]
   Before we get started with Laravel Dusk, let's update our test folder structure to match which ships with Laravel 5.4 to make it a little easier to integrate.

   - Summary
     - composer =psr-4= auto-loading
     - Mac is Uppercase noncase.

** DONE Getting Started with Laravel Dusk
   CLOSED: [2018-08-17 Fri 14:27]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 14:27]
   In this lesson, we install and configure =Laravel Dusk=, talk about some gotchas you might run into if you're not approaching it with the right mindset, and get a basic example browser test running.

   - Summary
     - Dusk use real database
     - Dusk visit =APP_URL= domain.

** DONE QA Testing the Login Flow
   CLOSED: [2018-08-17 Fri 14:37]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 14:37]
   In this lesson, we use Dusk to drive out a browser test for our login form to make sure we have regression coverage.

   - Tests
     - =logging_in_successful= in =PromoterLoginTest= =feature=
     - =logging_in_with_invalid_credential= in =PromoterLoginTest= =feature=
   - Summary
     - Dusk is used in regression test to simulate when broken app.

* Adding New Concerts

** DONE Preventing Guests from Adding Concerts
   CLOSED: [2018-08-17 Fri 14:54]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 14:54]
   In this lesson, we walk through some behind-scenes changes made since the last lesson and work on adding some basic authorization tests.

   - Tests
     - =promoters_can_view_the_add_concert_form= in =AddConcertTest= =feature=
     - =guests_cannot_view_the_add_concert_form= in =AddConcertTest= =feature=
   - Summary
     use =auth= middleware.

** DONE Adding a Valid Concert
   CLOSED: [2018-08-17 Fri 15:11]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 15:11]
   In this lesson we drive out the ability to add new concerts and make sure only promoters can access this endpoint.

   - Tests
     - =adding_a_valid_concert= in =AddConcertTest= =feature=
     - =guests_cannot_add_new_concerts= in =AddConcertTest= =feature=
   - Summary
     - =Carbon::parse(vsprintf('%s %s', request(['date', 'time'])))=

** DONE Validations and Redirects
   CLOSED: [2018-08-17 Fri 15:41]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 15:41]
   In this lesson we drive out our first validation rule for the concert form, and look at a useful trick for making assertions about =redirect()->back()= behavior.

   - Tests
     - =title_is_required=
   - Summary
     - Laravel validation error, then use =redirect()->back()= method, and the =back()= method use the =referer= header to get the from page and redriect the page.
     - =redirect()->back()= use =session()->previousURL()= to get previousURL
       #+BEGIN_SRC php
         private function from($url)
         {
             session()->setPriviousUrl(url($url));

             return $this;
         }
       #+END_SRC
** DONE Converting Empty Strings to Null
   CLOSED: [2018-08-17 Fri 15:48]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 15:48]
   In this lesson we add a test to prove that concert subtitles are optional, and active some new middleware from Laravel 5.4 to simplify the task.

   - Tests
     - =subtitle_is_optional= in =AddConcertTest= =feature=
   - Summary
     - Laravel 5.4 =TrimNullMiddleware=

** DONE Reducing Noise with Form Factories
   CLOSED: [2018-08-17 Fri 16:08]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 16:08]
   In this lesson we identify a lot of duplication in our validation tests and use a technique similar to model factires to clean up the noise.

   - Summary
     - add =validParam($overrides = [])= method.

** DONE Connecting Promoters to Concerts
   CLOSED: [2018-08-17 Fri 16:18]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 16:18]
   Up until now we've being operating under this assumption that we'd add concerts manually on a promoter's behalf.
   Now that promoters can add concerts themselves, we need to make sure we are tracking who adds each concert so we know who to transfer the ticket money to.

   - Summary
     - =Auth::user()->concerts()->create([])=, use relationship create concerts.

** DONE Autopublishing New Concerts
   CLOSED: [2018-08-17 Fri 16:42]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 16:42]
   In one of the earlist lessons in the course, we added some functionality to make sure that only published concerts were visible in the browser.
   Since we don't have ability to publish new concerts from the UI yet, let's at least make sure that new concerts are published by default until we get to that feature.

   - Tests
     - =concerts_can_be_published= in =ConcertTest= =unit=

* Listing a Promoter's Concerts
** DONE Asserting Against View Objects
   CLOSED: [2018-08-17 Fri 17:16]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 17:16]
   In this lesson we start driving out tests for a concert index page. We also talk about an incredibly useful strategy for making assertions about views without dealing with HTML.

   - Tests
     - =guests_connot_view_a_promoters_concert_list= in =ViewConcertListTest= =feature=
     - =promoters_can_view_a_list_of_their_concerts= in =ViewConcertListTest= =feature=
   - Summary
     - =$response->original= Illuminate return original data. If response is a view, it get the view object, and view =getData= method to get the pass through view data, such like =$response->original->getData()['concerts']=

** DONE Avoiding Sort-Sensitive Tests
   CLOSED: [2018-08-17 Fri 17:31]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 17:31]
   In this lesson I outline a small sort-order related trap you can fall into if you're not careful when asserting against lists of items, and talk about a stratey for avoiding it.

   - Tests
     - change =promoters_can_view_a_list_of_their_concerts= to =promoters_can_only_view_a_list_of_their_own_concerts= in =ViewConcertListTest= =feature=
   - Summary
     - Mix other user concert with needed concerts list, so can avoid paginate errors.

** DONE Refactoring Assertions with Macros
   CLOSED: [2018-08-17 Fri 17:49]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 17:49]
   In this lesson we work through using Laravel's macro feature to create more expressive custom assertions.

   - Summary
     - If use  =Macroable= Trait, then it can dynamic create method. =TestResponse= use the trait.
     - Macro =$response->original->getData()= to =$response->data()=
       #+BEGIN_SRC php
         TestResponse::macro('data', function ($key){
             $this->original->getData()[$key]; // $this is bind to TestResponse, not the current content.
         });
       #+END_SRC
     - Macro =assertContains=
       #+BEGIN_SRC php
         Collection::macro('assertContains', function ($value) {
             Assert::assertTrue($this->contains($value), "Failed asserting that the collection contains the value ");
         });
       #+END_SRC

* Upaditng Basic Concert Info

** DONE Viewing the Update Form
   CLOSED: [2018-08-17 Fri 18:06]
   - State "DONE"       from "STARTED"    [2018-08-17 Fri 18:06]
   In this lesson, I walk through some simple tests I put together behind-the-scenes to give us a head start on updating concerts.

** DONE The First Update Test
   CLOSED: [2018-08-18 Sat 05:30]
   - State "DONE"       from "STARTED"    [2018-08-18 Sat 05:30]
   In this lesson, we drive out the first test we need for editing concert details, and talk through a useful naming strategy to use when testing for attribute changes.
   - Test
     - =promoters_can_edit_their_own_unpublished_concerts= in =EditConcertTest= =unit=
   - Summary
     - When create data, name attribute with *old* prefix, and updated data with *new* prefix.
     - =patch= every time when edit.

** DONE Driving Out Basic Concept Updates
   CLOSED: [2018-08-18 Sat 05:43]
   - State "DONE"       from "STARTED"    [2018-08-18 Sat 05:43]
   In this lesson we implement the ability perform concert updates, and start working through some of the permissions checks we need to be concerned with.
   - Tests
     - =promoters_cannot_edit_other_unpublished_concerts= in =EditConcertTest= =unit=
   - Summary
     - When test the test, create old data, pass new data, and assert the data is still keep old stae.

** DONE Restricting Updates to Unpublished Concerts
   CLOSED: [2018-08-18 Sat 06:01]
   - State "DONE"       from "STARTED"    [2018-08-18 Sat 06:01]
   In this lesson we make sure only unpublished concerts can be edited, prevent guest from editing concerts, and drive out an example validation rule.
   - Tests
     - =promoters_cannot_edit_published_concerts= in =EditConcertTest= =feature=
     - =guests_cannot_edit_concerts= in =EditConcertTest= =feature=
   - Summary
     - SOP

* Postponing Ticket Creation

** DONE Storing the Intended Ticket Quantity
   CLOSED: [2018-08-18 Sat 06:11]
   - State "DONE"       from "STARTED"    [2018-08-18 Sat 06:11]
   In this lesson we figure out how to deal with updating the ticket quantity by deciding to delay ticket creation until publishing.
   - Tests
     - =ticket_quantit_is_required= in =EditConcertTest= =feature=
     - =ticket_quantity_must_be_interger= in =EditConcertTest= =feature=
     - =ticket_quantity_must_be_at_least_one= in =EditConcertTest= =feature=

** DONE Updating the Other Tests
   CLOSED: [2018-08-18 Sat 14:37]
   - State "DONE"       from "STARTED"    [2018-08-18 Sat 14:37]
   In this lesson we walk through some local tests failures caused by our design change and get things back to green.
   - Summary
     - Move find concert before validation.

** DONE Refactoring Away Some Test Duplication
   CLOSED: [2018-08-18 Sat 14:46]
   - State "DONE"       from "STARTED"    [2018-08-18 Sat 14:46]
   In this lesson we remove some repetitive setup and assertions by introducing a new test helper.
   - Summary
     - add method =oldAttributes($overrides = [])=
     - =assertArraySubset=

** DONE Creating Tickets at Time of Publish
   CLOSED: [2018-08-18 Sat 14:57]
   - State "DONE"       from "STARTED"    [2018-08-18 Sat 14:57]
   In this lesson we drive out the ability to create tickets at time of publish through our =Concert= unit tests, all while keeping our feature tests passing.
   - Summary
     - Move =addTickets= from controller to =publish=

** DONE Custom Factory Classes
   CLOSED: [2018-08-20 Mon 07:36]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 07:36]
   In this lesson we extract some repetitive complex factory setup into a custom =ConcertFactory= class.
   - Summary
     - Create =ConcertFactory= in =database= folder to create specified data in test and seeder.

* Publish Concert Drafts

** DONE Discoving a New Resource
   CLOSED: [2018-08-20 Mon 07:46]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 07:46]
   In this lesson we talk about three different approaches for exposing the ability to publish concerts through our applications endpoints.
   - Summary
     - use =PublishedConcertsController@store= to publish concert.

** DONE Creating Published Concerts
   CLOSED: [2018-08-20 Mon 08:00]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 08:00]
   In this lesson we drive out the ability to publish concerts through our new =/published-concerts= resource.
   - Tests
     - =a_promoter_can_publish_their_own_concerts= in =PublishConcertTest= =feature=
     - =a_concert_can_only_be_published_once= in =PublishConcertTest= =feature=
   - Summary
     - Expecting use =publish= method in =controller=, so assert the concert ticket remaining is correct number in database.
     - =abort_if=

** DONE Adding Concerts without Publishing
   CLOSED: [2018-08-20 Mon 08:11]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 08:11]
   In this lesson we update our existing "add concert" flow to not publish concerts immediately.
   - Tests
     - =a_promoter_cannot_publish_other_concerts= in =PublishConcertTest= =feature=
     - =a_guest_cannot_pubilsh_concerts= in =PublishConcertTest= =feature=
     - =concerts_that_donot_exist_cannot_be_published= =PublishConcertTest= =feature=
   - Summary
     - When create concert, do not publish it by default.

** DONE Pushing Logic Out of the View
   CLOSED: [2018-08-20 Mon 08:21]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 08:21]
   Our template is doing a little bit too much work. Let's figure out a way to extract some of that logic into a place that's easier to test.
   - Summary
     - Move view logic to controller

** DONE More Custom Assertion Fun
   CLOSED: [2018-08-20 Mon 09:17]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 09:17]
   Some of our assertions are looking a little bit overwhelming. Let's create a new custom assertion to make our test a bit more expressive.
   - Summary
     - Add =assertEquals= collection macro method.
       #+BEGIN_SRC php
         Collection::macro('assertEquals', function ($items) {
             Assert::equals($this->count(), $items->count());
             $this->zip($items, function ($pair) {
                 list($a, $b) = $pair;
                 Assert::equals($a->is($b));
             });
         });
       #+END_SRC
     - Add =createUnPublished= method in =ConcertFactory=

* Building the Sales Dashboard

** DONE Calculating Tickets Sold
   CLOSED: [2018-08-20 Mon 09:33]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 09:33]
   In this lesson walk through a few behind-the-scenes changes, then drive out a method for calculating tickets sold.
   - Tests
     - =a_promoter_can_view_the_orders_of_their_own_published_concerts= in =ViewPublishedConcertOrdersTest= =feature=
     - =a_promoter_cannot_view_the_orders_of_unpublished_concerts= in =ViewPublishedConcertOrdersTest= =feature=
     - =a_promoter_cannot_view_the_orders_of_another_published_concert= in =ViewPublishedConcertOrdersTest= =feature=
     - =a_guest_cannot_view_the_orders_of_any_published_concert= in =ViewPublishedConcertOrdersTest= =feature=
     - =tickets_sold_only_includes_tickets_associated_with_an_order= in =ConcertTest= =unit=
   - Summary
     - Add method =assertViewIs=
       #+BEGIN_SRC php
         TestResponse::macro('assertViewIs', function ($name) {
             Assert::assertEquals($name, $this->original->name());
         });
       #+END_SRC

** DONE Making the Progress Bar Work
   CLOSED: [2018-08-20 Mon 09:55]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 09:55]
   In this lesson we add some methods for calculating the percentage of ticket sold, and touch a neat tip for making assertions about float point numbers.
   - Tests
     - =total_tickets_includes_all_tickets= in =ConcertTest= =unit=
     - =calculating_the_percentage_of_tickets_sold= in =ConcertTest= =unit=
   - Summary
     - Donot put logic in the view, because we cannot test it.

** DONE Total Revenue and a Relationship Bug
   CLOSED: [2018-08-20 Mon 10:07]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 10:07]
   In this lesson we work on calculating the total revenue for a concert, but run into an intersting bug we need to tackle with our =$concert->order= relationship.
   - Tests
     - =calculating_the_revenue_in_dollars= in =ConcertTest= =unit=
   - Summary
     - Tickets and Orders are not belongsToMany relationship.


* Listing Recent Orders

** DONE Creating a Custom OrderFactory
   CLOSED: [2018-08-20 Mon 10:23]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 10:23]
   In this lesson we start working on making it possible for promoters to view a list of recent orders. When we hit a snag with some complex factory setup, we work on extracting a custom factory class to simplify our code.
   - Summary
     - Create order factory method =createForConcert=

** DONE Asserting Against Sort Order
   CLOSED: [2018-08-20 Mon 10:53]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 10:53]
   In this lesson we add the assertions we need to verify that our recent orders are getting passed to the view in the right order, and discuss why asserting against view data makes this so much easier that it would be if we were asserting against HTML.
   - Summary
     - Sublime =TextPastry=

** DONE Splitting Large Tests
   CLOSED: [2018-08-20 Mon 10:59]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 10:59]
   In this lesson we talk about when, why, and how to split up a large test into many.
   - Tests
     - =a_promoter_can_view_the_10_most_recent_orders_for_their_concert= in =ViewPublishedConcertOrdersTest= =feature=

* Queuing Mass Attendee Emails

** DONE Storing Messages for Attendees
   CLOSED: [2018-08-20 Mon 11:23]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 11:23]
   In this lesson we add the ability to create a new message to be sent to all concert attendees.
   - Tests
     - =a_promoter_can_view_the_message_form_for_their_own_concert= in =MessageAttendeesTest= =feature=
     - =a_promoter_cannot_view_the_message_form_for_another_concert= in =MessageAttendeesTest= =feature=
     - =a_guest_cannot_view_the_message_form_for_any_concert= in =MessageAttendeesTest= =feature=
     - =a_promoter_can_send_a_new_message= in =MessageAttendeesTest= =feature=

** DONE Confirming That a Job Was Dispatched
   CLOSED: [2018-08-20 Mon 11:35]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 11:35]
   In this lesson, we update our "store attendee message" implementation to actually dispatch a background job for sending the message.
   - Tests
     - =a_promoter_cannot_send_a_new_message_for_other_concerts= in =MessagesAttendeesTest= =feature=
     - =a_guest_cannot_send_a_new_message_for_any_concerts= in =MessagesAttendeesTest= =feature=
   - Summary
     - Queue assert
       #+BEGIN_SRC php
         Queue:fake();
         // ...

         Queue::assertPushed(SendAttendeeMessage::class, function ($job) use ($message) {
             return $job->message->is($message);
         });
       #+END_SRC

** DONE Unit Testing the Job
   CLOSED: [2018-08-20 Mon 12:42]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 12:42]
   In this lesson we drive out the implementation of the actual background job via a dedicated unit test.
   - Tests
     - =it_sends_the_message_to_all_concert_attendees= in =SendAttendeeMessageTest= =unit=

** DONE Refactoring for Robustness
   CLOSED: [2018-08-20 Mon 13:46]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 13:46]
   In this lesson we refactor the implementation of our background job to better handle large numbers of recipients.
   - Summary
     - Queued email: =Mail::to($recipient)->queue(AttendeeMessageEmail())=
     - Chunked recipients.

** DONE Mailable Testing Refresher and Demo
   CLOSED: [2018-08-20 Mon 13:54]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 13:54]
   In this lesson we walk through a unit test for our new mailable and demo our new mass email feature.
   - Tests
     - =email_has_the_correct_subject_and_message= in =AttendeeMessageEmailTest= =unit=

* Upgrading to Laravel 5.5

** DONE Upgrading to Laravel 5.5
   CLOSED: [2018-08-20 Mon 14:22]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 14:22]
   In this lesson we use our test suit to guide us as we upgrade to Laravel 5.5.

* Uploading Concert Posters

** DONE Faking Uploadings and File Systems.
   CLOSED: [2018-08-20 Mon 14:43]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 14:43]
   In this lesson we write our first test for uploading concert images, and walk through how to attach files to requests in feature tests, as well as how to use Laravel's built-in file system fake to make assertions about file uploads.
   - Tests
     - =poster_image_is_uploaded_if_included= in =AddConcertTest= =Feature=
   - Summary
     - Fake s3
       #+BEGIN_SRC php
         Storage::fake('s3');
       #+END_SRC
** DONE Storing Files and Comparing Contents
   CLOSED: [2018-08-20 Mon 14:59]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 14:59]
   In this lesson we get our initial file upload test passing, and also talk about how to verify that the stored file contents match the uploaded file contents.
   - Summary
     - Laravel =request('file')= get file instance
     - =assertFileEquals=

** DONE Validating Poster Images
   CLOSED: [2018-08-20 Mon 15:09]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 15:09]
   In this lesson we add additional tests for validating the file type, dimensions, and aspect ratio of uploaded concert posters.
   - Tests
     - =poster_image_must_be_an_image= in =AddConcertTest= =unit=
     - =poster_image_must_at_least_400px_wide= in =AddConcertTest= =unit=
     - =poster_image_must_have_letter_aspect_ratio= in =AddConcertTest= =unit=
   - Summary
     - Validate wide =Rule::dimension()->minWidth()=

** DONE Optional Files and the Null Object Pattern
   CLOSED: [2018-08-20 Mon 15:24]
   - State "DONE"       from "STARTED"    [2018-08-20 Mon 15:24]
   In this lesson we add a test to make sure that concert posters are optional, and come up with a clean implementation using the Null Object pattern.
   - Tests
     - =poster_image_is_optional= in =AddConcertTest= =unit=
   - Summary
     - Create =NullFile= file, used in =request('poster_image', new NullFile)=

* Optimizing Poster Images

** Testing Events
   In this lesson we decide on a design for our poster image processing feature and start by test-driving an event.

** Testing the Event Listener
   In this lesson we drive out our SchedulePosterImageProcessing event listener with TDD.

** Resizing the Posted Image
   In this lesson we walk through how to test resizing images using the =Intervention Image= image processing library.

** Optimizing the Image Size
   In this lesson we add an additional processing step to reduce the image size, and talk about how to test that the optimized image still looks like the original image.

* Inviting Promoters and Accepting Inivitations

** Upgrading Laravel and Deleting Some Code
   Before we get started with the next feature, let's quickly upgrade to the latest Laravel patch release and take advantage of some new features that let us delete some of our custom helpers.

** Viewing an Unused Inivation
   In this lesson, we drive out the ability for a promoter to view their inivitation to join TicketBeast.

** Viewing Used or Invalid Invitations
   In this lesson, we drive out what should happen when someone tries to view an invitation that has already been used, as well as inivation that doesn't exists.

** Registering with a Valid Invitation
   In this lesson we drive out the form endpoint for registering with a valid invitation code.

** Registering with an Invalid Invitation
   In this lesson we make sure that users can't register with invalid invitation codes.

** Validating Promoter Registation
   In this lesson we add some validation rules to our registeration flow.

** Testing a Console Command
   In this lesson we TDD a custom Artisan command for creating new invitations.

** Sending Promoters an Inivitation Email
   In this lesson we enhance our custom command to also send an invitation email to the promoter being invited.

** Test-Driving the Email Contents
   In this lesson we make sure that the inivitation email cotains the correct invitation linke, and run through a quick demo of our finished feature.

* Automating Payouts With Stripe Connect
** Getting Cozy with Stripe Connect
  In this lesson, we learn about how Stripe Connect works and drive out an initial test for the OAuth redirect flow using Laravel Dusk.

** Authorizing with Stripe
   In this lesson we implement the first half of the Stripe Connect redirect flow, where we send promoters to Stripe to connect their account.

** Exchanging Tokens
   In this lesson we handle the second half of the redirect flow; exchanging the temporary code Stripe gives us for a valid access token that we can use to make requests on behalf of a promoter.

** Unit Testing Middleware
   In this lesson we work on driving out a middleware that will force promoters to connect a Stripe account.

** Testing Callbacks with Invokables
   In this lesson we make sure our middleware doesn't block promoters who have already connected their Stripe accounts, covering an approach for testing their interfaces that accepts callbacks using invokables classes.

** Testing That Middleware is Applied
   In this lesson we discuss and implement a strategy for making sure that our new middleware is applied to the correct routes.

** Updating Factories and a Speed Trick
   In this lesson we check if our middleware has had any impact on the rest of our test suit, and walk through a quick trick that can dramatically speed up your test suit.

** Total Charges for a Specific Account
   In this lesson we start working on sending payments directly to promoters by making sure we can verify which accounts received which payments.

** Paying Promoters Directly
   In this lesson we make the necessary changes to our application code to make sure that when a payment is processed it's sent to the promoter's account instead of the application account.

** Splitting Payments with Stripe
   In this lesson we update our =StripePaymentGateway= to match our new payment gateway contract, and add an additional test to make sure that pyaments processed by Strip are split as expected between the application account and the promoter's account.

** It's Alive
   In the final lesson of Test-Driven Laravel, we do one last demo of the ticket purchasing process from inviting a promoter to receiving an order confirmation, and double check that everything is really working as expected via the Stripe dashboard.
