* STARTED Let's Build A Forum with Laravel and TDD
  A forum is a deceptively complex thing. Sure, it's made up of threads and replies, but what else might exist as part of a forum? What about profiles, or thread subscriptions, or filtering, or real-time notifications? As it turns out, a forum is the perfect project to stretch your programming muscles. In this series, we'll work together to build one with tests from A to Z.

** DONE Initial Database Setup With Seeding
   CLOSED: [2018-07-31 Tue 15:51]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 15:51]
   Let's begin by reviewing the most minimal requirements for a forum. If you think about it, we couldn't possibly construct a forum without users, and replies. So let's tackle those first.

** DONE Test-Driving Threads
   CLOSED: [2018-07-31 Tue 16:13]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 16:13]
   Now that we have our seed data in place, we can move on to our first small feature: "a user should be able to read threads." Simple enough! We'll start with a basic test, and then scaffold the necessary views to make it pass.
   - Occured Tests
     1. =a_user_can_view_all_threads=
     2. =a_user_can_read_a_single_thread=
   - Controller name is *plural*
   - Assert page has specificed title.
     #+BEGIN_SRC php
       $response = $this->get('/threads');

       $response->assertSee($thread->title);
     #+END_SRC
   - Route Model Binding
   - Let Model has the =path= method

** DONE A Thread Can Have Replies
   CLOSED: [2018-07-31 Tue 16:30]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 16:30]
   Now that we've added a basic feature for users to read forum threads, we can next move on to viewing all replies associated with each thread. As before, we'll start with a test to describe our desired outcome.
   - Occured Tests
     1. =a_user_can_read_replies_that_are_associated_with_a_thread=
     2. =it_has_an_owner= in =ReplyTest= unit test
   - Model =created_at= and =updated_at= are Carbon instance
   - =php artisan make test ReplyTest --unit=

** DONE A User May Respond To Threads
   CLOSED: [2018-07-31 Tue 17:09]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 17:09]
   We've implemented the necessary functionality to render a thread with all relevant replies, but we haven't yet allowed a user to type in a reply and submit it to the server. Let's get started on that now.
   - Occured Tests
     1. =a_thread_has_replies=
     2. =a_thread_has_a_creator=
     3. =an_authenticated_user_may_participate_in_forum_threads=
     4. =a_thread_can_add_a_reply=
     5. =unauthenticated_users_may_not_add_replies=
   - Blade =@include= can inherit parent variables
   - =phpunit --filter <test-name>=
   - =$this->be($user)= sign in a user when test

** DONE The Reply Forum
   CLOSED: [2018-07-31 Tue 17:18]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 17:18]
   Now that we've tested the end-point for adding a new reply, the only remaining step is to create the HTML for the form. in the process, we'll also ensure that only logged-in users are able to see it.

** DONE A User May Publish Threads
   CLOSED: [2018-07-31 Tue 17:29]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 17:29]
   So far, a user can read and reply to threads, but they don't yet have the ability to publish their own threads. Let's begin fixing that in this episode.
   - Tests
     1. =an_authenticated_user_can_create_new_forum_threads=
     2. =guests_may_not_create_threads=

** DONE Let's Make Some Testing Helpers
   CLOSED: [2018-07-31 Tue 17:38]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 17:38]
   I'm a big fan of making the process of writing tests as natural as humanly possible. The harder it is to construct a test, the more likely it is your simply...won't. With that in mind, let's extract a few helpers and snippets to assist us.
   - functions
     1. =create()=
     2. =make()=
     3. =signIn()=

** DONE The Exception Handling Conundrum
   CLOSED: [2018-07-31 Tue 17:52]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 17:52]
   Now that our endpoint tests are returning green, we can construct the HTML forum to publish a new thread. However, in the process, we'll stumble upon an odd exception handling issue that needs to be addressed. Luckily, Adam Wathan has a useful solution that we can implement.
   - tests
     1. =guests_cannot_see_the_create_thread_page=

** DONE A Thread Should Be Assigned a Channel
   CLOSED: [2018-07-31 Tue 18:12]
   - State "DONE"       from "STARTED"    [2018-07-31 Tue 18:12]
   Right now, all threads are thrown into the same "global" namespace, so to speak. Ideally, we should assign each thread to a channel. That way, for a development forum, we may easily filter threads by PHP, or JavaScript, or Servers.
   - Tests
     1. =a_thread_belongs_to_a_channel=
     2. =a_thread_can_make_a_string_path=

** DONE How to Test Validation Errors
   CLOSED: [2018-08-01 Wed 09:57]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 09:57]
   We haven't written any validation logic yet for our forum. This means that a user could whip up a request with all sorts of invalid data, and we gladly persist it to the database. Let's fix that in this episode, while writing tests to ensure that everything functions as we expect.
   - Tests
     1. =a_thread_requires_a_title=
     2. =a_thread_requires_a_body=
     3. =a_thread_requires_a_validate_channel=
     4. =a_reply_requires_a_body=
   - Get response Location =$response->headers->get('Location')=
   - =assertSessionHasErrors('property')= when test validation errors
   - Encapsulate =disabledErrorHandling= and =signIn= and =post to server=  in =publishThread= for quickly test =Validation Errors=

** DONE Users Can Filter Threads By Channel
   CLOSED: [2018-08-01 Wed 10:18]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 10:18]
   Now that we've associated all threads with a channel, we can now perform the necessary UI updates to allow users to filter threads by their desired channel.
   - Tests
     - =a_user_can_filter_threads_according_to_a_tag=
     - =a_channel_consists_of_threads=
   - =Route Model Binding= use the =getRouteKeyName= method to change binding column.

** DONE Validation Errors and Old Data
   CLOSED: [2018-08-01 Wed 10:32]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 10:32]
   In this episode, we need to do a bit of work on the "create thread" page. We'll first add a link to the navigation bar, and then move on to tweaking the form, itself. Specifically, we shuld provide validation error feedback, and ensure that any text that the user types into the forum's various fields will be remembered if a validation error is triggered.
   - =old()= method to fetch the user typed

** DONE Extracting to View Composers
   CLOSED: [2018-08-01 Wed 10:51]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 10:51]
   Currently, we have two different SQL queries for fetching all channels directly in our view layer. Let's fix that by extracting a dedicated view composer.
   - =View::composer('<blade>', closure)=
   - =View::share('<blade>', closure)=

** DONE A User Can Filter All Threads By Username
   CLOSED: [2018-08-01 Wed 11:03]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 11:03]
   It would be nice if any user could have a link that displays only the threads that they've personally created. Even beyond that, why not allow for the ability to view any forum user's threads? Let's figure out how in this episode.
   - Tests
     1. =a_user_can_filter_threads_by_any_username=

** DONE A Lession In Refactoring
   CLOSED: [2018-08-01 Wed 11:33]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 11:33]
   Since it seems that filtering will be an important component to our application, let's take a bit of time to perform some refactoring. Luckily, because we have a set of tests to back us up every step of the way, we can be as bold as wish. There's no fear of breaking the app, if your tests will notify you the second you make a refactoring error.
   - Sequence
     1. ThreadsController@index
     2. Thread@scopeFilter
     3. ThreadFilters@apply
     4. Abstract Filters

** DONE Meta Details and Pagination
   CLOSED: [2018-08-01 Wed 14:13]
   - State "DONE"       from "TODO"       [2018-08-01 Wed 14:13]
   We should add a sidebar to each thread page for various meta information, such as when the thread was published, how many replies it has, and more. Further, we've yet to add pagination to our app. What happens when a thread has over one hundred replies? Let's ensure that we put the propper pagination links in place.
   - Add replies count method
     1. =$thread->replies->count()=
     2. =$thread->replies()->count()=
     3. =$thread->withCount('replies')=
     4. In =static::addGlobalScoped($builder)= add =$thread->withCount('replies')=
     5. use dynamic attribute =getRepliesCountAttribute=
   - =str_plural()=
   - Replationship Pagination =$thread->replies()->paginate(10)=

** DONE A User Can Filter Threads By Popularity
   CLOSED: [2018-08-01 Wed 14:44]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 14:44]
   It would be nice if users had the ability to filter all threads by popularity. That way, the most active threads will bubble to the top of the stack. Let's write a test and then implement this very feature.
   - Tests
     1. =a_user_can_filter_threads_by_popularity=
   - Use relationship to order =$thread->orderBy('replies_count', 'desc')=
   - Clear exists =orders=: =$this->builder->getQuery()->order = []=

** DONE A User Can Favorite Replies
   CLOSED: [2018-08-01 Wed 15:09]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 15:09]
   It would be useful if authenticated users could have the ability to "favorite" any reply within a thread. Let's begin impementing that functionality now, by using polymorphic relations.
   - Tests
     1. =an_authenticated_user_can_favorite_any_reply=
     2. =guest_cannot_favorite_anything=
     3. =an_authenticated_user_may_only_favorite_a_reply_once=

** DONE The Favorite Button
   CLOSED: [2018-08-01 Wed 15:33]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 15:33]
   Now that we've tested the full process of favoriting a reply, we can move on to creating the form to process this action for the user. In the process, we'll begin discussing the N+1 problem.
   - =$thread->load('replies')=, eager load one layer relationship
   - =$thread->load('replies.favorites)->load('replies.owner')=, eager load more layer relationships
   - =$this->hasMany()->withCount('favorties')= in =Thread@replies=, defined relationship and eagor count the favorites count for replies.

** DONE From 56 Quries Down to 2
   CLOSED: [2018-08-01 Wed 15:44]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 15:44]
   Let's review the N+1 problem, as it relates to Eloquent. To do so, we'll install =Laravel Debugbar= so that we can analyze the exact SQL quires that are being executed for each page load. As you'll learn, there are a variety of simple steps we can follow to reduce our query count by the dozens.

** DONE Global Scopes and Further Query Reduction
   CLOSED: [2018-08-01 Wed 16:04]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 16:04]
   In this episode, we'll continue optimizing our SQL queries. Specifically, we'll review global Eloquent scopes and the useful =$with= property to automatically eager load any necessary relationships.
   - =protected $with= property, global eager load relationship

** DONE A User Has a Profile
   CLOSED: [2018-08-01 Wed 16:21]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 16:21]
   It would be useful if every user in our forum had an associated profile page. That way, we can review more information about them, including all threads that they've personally created.
   - Tests
     1. =a_user_has_a_profile=
     2. =profiles_display_all_threads_created_by_the associated_user=

** DONE A User Can Delete Their Threads
   CLOSED: [2018-08-01 Wed 16:39]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 16:39]
   One simple ability that we haven't yet implemented is the option to delete threads. If "John Doe" creates a thread and later change his mind, let's allow him to delete it entirely.
   - Tests
     1. =a_thread_can_be_deleted=
     2. =guests_cannot_delete_threads=
     3. =threads_may_only_be_deleted_by_those_who_has_permission=

** DONE Authorization with Polices
   CLOSED: [2018-08-01 Wed 17:00]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 17:00]
   We must be careful that we don't inadvertently give any registered form user the ability to delete all threads. Let's create a policy class to ensure that this cann't happen.
   - Tests
     1. =unauthrozed_users_may_not_delete_threads=
     2. =authorized_users_can_delete_threads=

** DONE How to Construct an Activity Feed with TDD
   CLOSED: [2018-08-01 Wed 17:29]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 17:29]
   In this episode, we'll use TDD to drive out and activity feed. That way, we can, for example, track when a user creates a new forum thread, or posts a reply. As always, we'll begin with the most basic implementation. Once we get to green, we can then move on to the refactoring stage to clean things up drastically.
   - Tests
     1. =it_records_activity_when_a_thread_is_created=
     2. =it_records_activity_when_a_reply_is_created=
   - Use trait it Laravel, it will auto trigger =boot<TraitName>= method.

** DONE How To Construct an Activity Feed with TDD: Part 2
   CLOSED: [2018-08-01 Wed 17:49]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 17:49]
   Now that we've written the necessary code to record all relevant activity, in this episode, we can render it onto the user's profile page, and group all relevant records according to their date.
   - Basic polymorphic views
   - =groupBy(closure)=
   - =@component= blade directive

** DONE Extracting Controller Queries to the Model
   CLOSED: [2018-08-01 Wed 18:00]
   - State "DONE"       from "STARTED"    [2018-08-01 Wed 18:00]
   At the moment, we have long, fluent Eloquent query in our controller. Instead, let's use TDD to extract it into the =Activity= model.
   - Tests
     1. =it_fetch_a_feed_for_any_user=
** DONE The Activity Deletion Bug
   CLOSED: [2018-08-02 Thu 09:26]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 09:26]
   I think we have a bug in our activity feed. What happens if we delete a thread? Will that cascade and delete all relevant activity in the process? And, if not, what happens when we try to view the user's profile page? Hmm, let's write a regression test to find out.
   - Tests
     - =authorized_users_can_delete_threads=
   - =$thread->replies()->delete()= this is queryBuilder, so can not trigger =deleting= event. If want to trigger event, should use =$thread->replies->each->delete()= Eloquent collections.

** DONE Flash Messaging with Vue
   CLOSED: [2018-08-02 Thu 09:48]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 09:48]
   In this episode, we'll implement an elegant flash messaging system, using Vue. That way, when a user performs an important action, we can flash a quick message to indicate the outcome.
   - =redirect('/route')->with('flash', 'You state has been updated')= Redirect with flash session message.
   - Vue instance implement Event bus

** DONE A User's Activity Feed Should Include Favorited Replies
   CLOSED: [2018-08-02 Thu 09:58]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 09:58]
   At the moment, a user's activity feed will exclusively display a timeline of their own threads and replies. Let's extend that in this episode to include any replies that they've favorited.
   =view('<file-path>')->exists()=

** DONE Authorized Users Can Delete Replies
   CLOSED: [2018-08-02 Thu 10:10]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 10:10]
   We're still missing a very basic piece of functionality. Any authorized user should be able to delete a reply. Let's implement that in this episode.
   - Tests
     - =unauthorized_users_cannot_delete_replies=
     - =authorized_users_can_delete_replies=

** DONE A Vue Reply Component
   CLOSED: [2018-08-02 Thu 10:34]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 10:34]
   We're starting to realize that each individual form reply should have a decent amount of behavior associated with it. With that in mind, in this episode we'll create a dedicated Vue component for a reply, and then implement the necessary functionality to quickly edit the body of a reply without requiring a page refresh.
   - Tests
     - =authorized_users_can_update_replies=
     - =unauthorized_users_cannot_update_replies=
   - =inline-template=
   - =:attribute = {{ $reply }}= $reply object automatically transform to json object to Vue props.

** DONE Ajaxifying The Delete Button
   CLOSED: [2018-08-02 Thu 10:47]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 10:47]
   Now that each reply is wrapped within a dedicated Vue instance, we can easily swap out the traditional form for deleting the reply with a snappier AJAX version that doesn't require a page refresh.
   - =$(this.$el).fadeOut(300)= self fade out after 300ms

** DONE A Vue Favorite Component
   CLOSED: [2018-08-02 Thu 11:10]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 11:10]
   We have one last piece of the puzzle, when it comes to our =Reply= component. The favoriting functionality still consists of a traditional form. Let's turn that into a dedicated =Favorite= component to clean things up.
   - Tests
     - =an_authenticated_user_can_unfavorite_a_reply=
   - =$appends= Laravel model append attribute
   - Vue bind classes with computed property
     #+BEGIN_SRC js
       computed: () {
           return ['btn', this.isFavorited ? 'btn-primary' : 'btn-default'];
       }
     #+END_SRC
   - =isFavorited= to =active= and =favoritesCount= to =count=

** DONE Squashing Bugs
   CLOSED: [2018-08-02 Thu 11:26]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 11:26]
   I think we've introduced a couple of bugs related to adding and removing activity. Let's work through them in this episode and patch things up, before moving on to a new feature.

** DONE A More Data-Centric Approach
   CLOSED: [2018-08-02 Thu 11:54]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 11:54]
   In this episode, we'll do a decent amount of refactoring to push toward a more data-centric approach, when it comes to our Vue components. As part of this refactor, we'll need to figure out how to rewrite inline-templates that use Blade into JavaScript.
   - =pages/Thread.vue=
   - Remove a item from list: =this.item.splice(index, 1)=
   - Props convensions =initial<Props>=
   - Register user is signIn in =window.App= variable.
   - Pass can authorized property to element.
   - Vue prototype authorize
     #+BEGIN_SRC js
       Vue.prototype.authorize = function(handler) {
           return handler(window.App.user)
       })
     #+END_SRC

** DONE A New Reply Component
   CLOSED: [2018-08-02 Thu 12:31]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 12:31]
   Now that we're thinking in terms of Vue collections, we can easily turn the form for publishing a new reply into its own component. This way, when the user submit the form, we can simply perform an AJAX call to persist the data, and then push to the "replies" collection - which will, in response, automatically trigger a re-render.
   - =$reply->load('owner')=
   - =loaction.pathname= get current url path

** DONE Laravel and Vue Pagination
   CLOSED: [2018-08-02 Thu 14:16]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 14:16]
   Since we're now rendering all replies with JavaScript, we can no longer depend upon rendering pagination links on the server side. To compensate, let's crete a dedicated =paginator= Vue component to handle all the necessary logic behavior.
   - Tests
     - =a_user_can_request_all_replies_for_a_given_thread=
   - Vue =Mixins=
   - =history.pushState= update url

** DONE A User Can Filter By Unawnsered Threads
   CLOSED: [2018-08-02 Thu 14:39]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 14:39]
   I've learned from running the laracasts forum that users often want to filter all threads according to those that have not yet received replies. Let's add that very functionality in this episode.
   - Tests
     - =a_user_can_filter_threads_by_those_that_are_unawsered=

** DONE Thread Subscriptions: Part 1
   CLOSED: [2018-08-02 Thu 14:55]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 14:55]
   It would be useful if users could subscribe to any number of threads in our forum. That way, each time a reply is left, the user will immediately be notified. Let's get started implementing this very functionality.
   - Tests
     - =a_thread_can_be_subscribed_to=
     - =a_thread_can_be_unsubscribed_from=

** DONE Thread Subscriptions: Part 2
   CLOSED: [2018-08-02 Thu 15:10]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 15:10]
   Now that our model tests prove that users can properly subscribe to threads. let's move up a level and right the general feature that describes what should happen when a particular endpoint is triggered.
   - Tests
     - =a_user_can_subscribe_to_threads=

** DONE Thread Subscriptions: Part 3
   CLOSED: [2018-08-02 Thu 15:29]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 15:29]
   Let's take a bit of time on the UI side of things. We need to prepare a "subscribe" Vue component that handles the behavior of toggling the current user's subscription to any given thread.
   - Tests
     - =it_knows_if_the_authenticated_user_is_subscribed_to_it=
     - =a_user_can_unsubscribe_from_threads=
   - =json_encode(boolean)= return the boolean string type

** DONE Thread Subscriptions: Part 4
   CLOSED: [2018-08-02 Thu 16:07]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 16:07]
   Now that a thread exposes the behavior that it can be subscribed to, we can move on to preparing all relevant user notifications each time the thread receive a new reply. To allow for this, we'll leverage Laravel's native notifications functionality.
   - Tests
     - =a_notification_is_prepared_when_a_subscribed_thread_receievs_a_new_reply_that_is_not_by_the_current_user=
     - =a_user_can_mark_a_notification_as_read=
     - =a_user_can_fetch_their_unread_notifications=

** DONE Test Refactoring
   CLOSED: [2018-08-02 Thu 16:19]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 16:19]
   Let's take a few moments to refactor the tests in our =NotificationsTest= class. A handful of tweaks should makes this file far more simple to read and understand six months from now.
   - =tap()=

** DONE Thread Subscriptions: Part 5
   CLOSED: [2018-08-02 Thu 16:36]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 16:36]
   We can finally switch over to the client-side, and begin constructing a =user-notifications= Vue component the will be responsible for fectching all relevant notifcations and rendering them within a "bell" dropdown panel.

** DONE Refactoring for the Better or Worse?
   CLOSED: [2018-08-02 Thu 16:55]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 16:55]
   Let's perform a round of refactoring in this episode. But there's a twist! At the conclusion of the refactor, we'll take a very important step. That step is to ask ourselvers, "Is the code better as a result of this refactor? Or did we make it more confusing?"
   - As simple and clean as possible.

** DONE Notification Fakes in a Nutshell
   CLOSED: [2018-08-02 Thu 17:04]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 17:04]
   If you check out =ThreadTest= class, you'll notice that we don't yet have a test that asserts that, each time a reply is added to a thread, a notification should be prepared for all thread subscribers. Let's use a notification fake to test this functionality.
   - Tests
     - =a_thread_notifies_all_registered_subscribers_when_a_reply_is_added=
   - =Notification::fake()= and =assertSendTo()=

** DONE This Thread Has Been Updated Since You Last Read It.
   CLOSED: [2018-08-02 Thu 17:32]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 17:32]
   It would be useful if users could have a small visual cue that any given thread has been updated since they last read it. This indication could be as small as making the title of the thread bold in such instances. So how do we allow for this? Well, while there's countless ways to implement this, let's try using basic caching.
   - Tests
     - =a_thread_can_check_if_the_authenticated_user_has_read_all_replies=
   - =<some-thing>CacheKey=

** DONE Spam Detection
   CLOSED: [2018-08-02 Thu 17:54]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 17:54]
   Spam is a sad reality of any successful forum, and we can't ignore it. In this episode, let's begin constructing a series of spam detectors. We'll start with basic keyword detection, but this will soon evolve to all sorts of inspections.
   - Tests
     - =replies_that_contain_spam_may_not_be_created=
     - =it_validates_spam=
   - Use Tests to play the code for what I want.

** DONE Graduating Inspection Methods to Classes
   CLOSED: [2018-08-02 Thu 18:09]
   - State "DONE"       from "STARTED"    [2018-08-02 Thu 18:09]
   Rather than adding countless inspections to our single =Spam= class, instead, let's elevate each of these inspections to its own class. Then, our =Spam= class can simply filter through all registered inspections, and trigger them. Much cleaner.
   - Tests
     - =it_checks_invalid_keywords=
     - =it_checks_any_key_being_held_down=
   - Detect great equal than 4 characters =preg_match('/(.)\\1{4,}/', 'aaaaaaa', $match)=

** DONE Spam Detection At All Ports
   CLOSED: [2018-08-03 Fri 07:59]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 07:59]
   At the moment, we only perform spam detection when the user writes a new reply. But what about when they update the new reply, or post a new thread entriely? In this lesson, we'll review some options for performing spam detection for each of these actions.
   - When replicate code more than three sceonds, it should be refactor.

** DONE Handling Server Exceptions with JavaScript
   CLOSED: [2018-08-03 Fri 09:58]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 09:58]
   At this point, our spam detection is working perfectly. However, our frentend still needs a few updates to properly translate any possible exceptions into feedback for the user. Let's tacle that in this episode.
   - After change =package.json= file
     - remove =package.json.lock= file
     - remove =node_modules/*= files
     - run =npm install= command
   - =npm list --depth=0=

** DONE Refactoring to Custom Validation
   CLOSED: [2018-08-03 Fri 10:12]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 10:12]
   As we've implemented our spam detection layer, have you noticed that we've split the validation process into two steps? First, we trigger Laravel's built-in validators, then we apply our spam detection. What if we could create a custom validation rule instead and clean up our code in the process? Well , we can
   - Extend Validator: =Validator::extend('spamfree', 'App\Rules\SpamFree@passes')=
   - Validation Message in =resources/lang/en/validation.php=

** DONE A User May Not Reply More Than Once Per Minute
   CLOSED: [2018-08-03 Fri 10:35]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 10:35]
   At the moment, any spanner can write a program to leave a forum reply every five seconds. Yikes! Let's at the very least limit users to no more than one reply per minute.
   - Tests
     - =users_may_only_reply_a_maximum_of_once_per_minute=
     - =a_user_can_fetch_their_most_recent_reply=
     - =it_knows_if_it_was_just_published= in =ReplyTest=
   - Ways
     1. Compare current user last reply create time.
        In policy class
     2. Use =throttle= middleware
   - Use =lastReply= in relationship
     - =return $this->hasOne(Reply::class)->latest()=
   - When test not expect, consider is eager loading problem.

** DONE Refactoring to Form Requests
   CLOSED: [2018-08-03 Fri 11:02]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 11:02]
   The =RepliesController= method that handles the submission of a new reply still feels a bit bloated to me. In this episode, we'll refactor it down to a single method call.
   - =php artisan make:request CreatePostForm=
   - Overrided requestForm =failedAuthorization= method.

** DONE Mentioned Users Notification: Part 1
   CLOSED: [2018-08-03 Fri 11:23]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 11:23]
   The next feature we need to implement is the ability for users to receive automatic notifications each time their username is mentioned within a thread. We'll get started in this episode by preparing a test, and then writing the least amount of code to get it to green.
   - Tests
     - =mentioned_a_user_in_reply_is_notified= in =MentionUsersTest=
   - =preg_match_all('/\@[^\s\.]+/', $reply->body, $matches)= match all reply body that start '@' and end '.' or ' ' characters.

** DONE Mentioned Users Notification: Part 2
   CLOSED: [2018-08-03 Fri 11:39]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 11:39]
   Now that we're at green, we can begin refactoring out code. Let's use a basic eventing setup, now that we have multiple actions that need to take place each time a reply is posted.
   - Tests
     - =it_can_detect_all_mentioned_users_in-the_body= in =ReplyTest=
   - =filter()= method without any arguments, will filter all empty items.

** DONE Don't Forget to Scan Your Files
   CLOSED: [2018-08-03 Fri 12:39]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 12:39]
   An important part of your workflow involves file scanning. Yes, your code works. Yes, the test pass. But, even so, take a third pass and scall all relevant files. Does anything jump out at you? Are there any small tweaks that might add more clarity? Should that variable be inlined? Can we reduce the number of queries over here?

** DONE Wrap Usernames Within Anchor Tags
   CLOSED: [2018-08-03 Fri 12:51]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 12:51]
   Now that we can successfully notify mentioned usernames within a reply, let's begin updating the UI. First up, we'll match any usernames, and wrap them within anchor tags that link to their profile.
   - Tests
     - =it_wraps_mentioned_usernames_in_the_body_within_anchor_tags= in =ReplyTest=
   - =setBodyAttribute=
   - =preg_replace('/@([\w\-]+)/', '<a href="/profiles/$1">$0</a>', $body)=
** DONE Instant Username Autocompletion
   CLOSED: [2018-08-03 Fri 13:49]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 13:49]
   In this episode, we'll begin researching how to allow for GitHub-style instant =@username= autocompletion. During the research phase, we'll set up a brand new throw-away project to learn =how it will work=. Then, once we feel comfortable, in the next episode we'll intergrate autocompletion into our forum.
   - =v-html=
   - [[github.com/ichord/At.js][At.js]]

** DONE Instant Username Autocompletion: Part 2
   CLOSED: [2018-08-03 Fri 14:13]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 14:13]
   Now that we understand how the At.js plugin works, we can begin integrating it into our forum. Let's get a working implementation setup in this episode.
   - Tests
     - =it_can_fetch_all_mentioned_users_starting_with_the_given_characters= in =MentionUsersTest=

** DONE Basic View Tweaks
   CLOSED: [2018-08-03 Fri 14:25]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 14:25]
   Before we move on to a few more important new features, let's take some time to perform some smaller tweaks. For instance, on the thread listing page, we should display the author's name. Additionally, we aren't using pagination here. Let's fix both of these issues now.

** DONE Testing Avatar Uploads
   CLOSED: [2018-08-03 Fri 14:49]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 14:49]
   We should next allow users to upload avatars for their profile. As always, let's take a test-driven approach to thisk task. As you'll find, Laravel offers a number of resources to make the process of testing file uploads incredibly easy.
   - Tests
     - =only_members_can_add_avatars= in =AddAvatarTest=
     - =a_valid_avatar_must_be_provided= in =AddAvatarTest=
     - =a_user_may_add_avatar_to_their_profile=
   - =UploadedFile::fake()->image('avatar.jpg')=
   - =Storage::fake()=
   - =Storage::disk('public')->assertExists('avatars/avatars.jpg')=
   - =$file->hashName()=

** DONE Testing Avatar Uploads: Part 2
   CLOSED: [2018-08-03 Fri 15:12]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 15:12]
   Now that we've mostly driven out the backend side of things, let's shift our attention to the view layer. We should present a form to the user, so that they may choose an avatar to upload and associate with their profile.
   - Tests
     - =a_user_can_determine_their_avatar_path= in =UserTest=

** DONE AJAX Image Uploads
   CLOSED: [2018-08-03 Fri 15:53]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 15:53]
   If we'd like to use AJAX to update a user's profile image, we'll need to take a few somewhat tricky steps. Don't worry, it's not too rough. When we're done, we'll have seamless integration with instant feedback.
   - ReadAsDataURL
     #+BEGIN_SRC js
       onChange(e) {
           if (! e.target.files.length) return;

           let file = e.target.files[0];

           let reader = new FileReader();

           reader.readAsDataURL(file);

           reader.onload = e => {
               this.avatar = e.target.result;
           };

           this.persist(file);
       }
     #+END_SRC
   - Persist
     #+BEGIN_SRC js
       persist($avatar) {
           let data = new FormData();

           data.append('avatar', avatar);

           axios.post('endpoint', data);

       }
     #+END_SRC
   - Vue normal props merge to the component's root element.

** DONE Trending Threads with Redis
   CLOSED: [2018-08-03 Fri 16:18]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 16:18]
   It would be useful if visitors could instantly see which threads are currently trending on our forum. An incredibly simply way to implement this is through sorted sets with Redis. Let's get started.
   - Tests
     - =it_incremens_a_thread_score_each_time_it_is_read= in =TrendingThreadsTest=
   - Redis sorted sets
     #+BEGIN_SRC bash
       zincrby 'trending_threads' 1 'Some thread title'

       zincrby 'trending_threads' 1 'Another thread title'

       zrange 'treanding_threads' 0 -1
     #+END_SRC

** DONE Isolating Knowledge
   CLOSED: [2018-08-03 Fri 16:34]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 16:34]
   In this episode, we'll continue reviewing our trending threads in Redis logic. Could we possibly extract this code to a dedicated class? And if we did so, what benifits might we encounter as a result?

** DONE Thread Views: Design #1 - Trait
   CLOSED: [2018-08-03 Fri 16:54]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 16:54]
   We next need to display the visits/views count for each thread on each page. If only for learning purposes, we'll review three different implementations - one per episode - while discussing the pros and cons for each. To begin, let's assume that the forum we're building will be incredibly popular. If so, we might consider using Redis to track and increment the views count each time the page is loaded. Let's get started.
   - Tests
     - =a_theard_record_each_visit= in =ThreadTest=

** DONE Thread Views: Design #2 - Extract Class
   CLOSED: [2018-08-03 Fri 17:07]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 17:07]
   In the previous episode, we successfully recorded the views count through a single trait, or concern. However, you may notice that the "visit"  suffix is referenced in a number of method names. When you encounter repeated keywords, often it's an indication that a class is requesting to be extracted. Let's tacle that very thing in this episode, and then review the before and later.

** DONE Thread Views: Design #3 - KISS
   CLOSED: [2018-08-03 Fri 17:28]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 17:28]
   Finally, we've made it to our third and final design choice: KISS. A vital skill for all web developers in to understand when certain optimizations and refactors are necessary, and when it simply doesn't matter. In the case of this particular feature, would it be easier if we simply added a "visit" column to our threads table? Yes, we'd need to increment this count each time a thread is read, but is that necessarily a problem? Are we anticipating a scale and level of traffic that demands such an optimizations? If not, keep it simple.
   - Tests
     - =we_record_a_new_visit_each_time_the_thread_is_read= in =ReadThreadTests=
   - Keep it simple and stupid

** DONE Users Must Confirm Their Email Address #1: Protection
   CLOSED: [2018-08-03 Fri 17:52]
   - State "DONE"       from "STARTED"    [2018-08-03 Fri 17:52]
   If spam is a significant concern, one option is to force all forum users to first confirm their email address before we grant access to publish new threads. Typically, spammers will enter gibberish email addresses during the sign up process. With this modification, a real email address will be required.
   - Tests
     - =authenticated_users_must_first_confirm_their_email_address_before_creating_threads=
   - =php artisan make:middleware RedirectIfEmailNotConfirmed=

** DONE Users Must Confirm Their Email Address: #2 - Confirmation
   CLOSED: [2018-08-06 Mon 10:29]
   - State "DONE"       from "STARTED"    [2018-08-06 Mon 10:29]
   Now that we have the proper protections in place, we can move on to the next step: sending all new users an email confirmation request upon registration. Once they click back to our website through this link, we can mark their account as confirmed, and they may they begin posting to the furm.
   - Tests
     - =a_confirmation_email_is_sent_upon_registration= in =RegistrationTest=
     - =user_can_fully_confirm_their_email_addresses=
   - =protected $casts=

** DONE Users Must Confirm Their Email Address #3: -Cleanup
   CLOSED: [2018-08-06 Mon 10:57]
   - State "DONE"       from "STARTED"    [2018-08-06 Mon 10:57]
   At this point, everything appears to be working properly. So let's take this episode to simplify a sections, remove the event listener approach, and clean up our code.
   - Tests
     - =confirming_an_invalid_token= in =RegistrationTest=
   - =factory(User::class, uncomfirmed', closure)=
