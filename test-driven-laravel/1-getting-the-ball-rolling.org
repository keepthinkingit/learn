* Getting the Ball Rolling
** What Do We Build First
   First of all, welcome to Test-Driven Laravel!
   To get things started, let's talk a bit about the app we are going to build, and figure out where we should start.
   [[~/Documents/tutorials/test-driven-laravel/1-getting-the-ball-rolling/1-what-do-we-build-first.mp4][1-what-do-we-build-first.mp4]]
** Sketching out Our First Test
   In this lesson, we scaffold out a new application and start sketching out the first test.

** Getting to Green
   In this lesson, we use TDD to scaffold out a lot of the boiler plate in the application and get our first test passing.

** Unit Testing Presentation Logic
   In this lesson, we drive out some presentation helpers via unit tests to extract some logic from our view.

** Refactoring For Speed
   In this lesson, we finish extracting some presentation helpers, then refactor our tests to run without using the database to keep thing fast.

** Hiding Unpublished Concerts
   In this lesson, we introduce the idea of "published" and "unpublished" concerts, and hide unpblished concerts from visitors to the site.

** Testing Query Scopes
   In this lesson, we extract some query logic to a custom scope and ensure that it's covered by our tests.

** Factory States
   In this lesson, we abstract some details about makes a concert "published" from our tests by encapsulating them in a factory state.

* Purchasing Concert Tickets
** Intro
   In this lesson, we talk about getting started with the "Purchasing Concert Tickets" feature that we're going to implement next.

** Browser Testing vs Endpoint Testing
   In this lesson, we talk about the trade-offs involved in testing through the browser vs. testing endpoint directly, and why you might choose one option over the other.

** Outlining the First Purchasing Test
   In this lesson, we design our initial "customer can purchase concert tickets" test.

** Faking the Payment Gateway
   In this lesson, we create a fake implementation of our payment gateway to avoid hitting Stripe during our intergration tests.

** Adding Tickets to Orders
   In this lesson, we work on creating tickets and attaching them to orders when a customer make a purchase.

** Encapsulating Relactionship Logic in the Model
   In this lesson, we work on refactoring some of our controller code and pushing some logic into the model.

** Getting Started with Validation Testing
   In this lesson, we work on testing and implementing some request validation rules.

** Reducing Duplication with Custom Assertion
   In this lesson, we abstract some commonly paired assertions behind a custom assertion with a more expressive name.

** Handling Failed Charges
   In this lesson, we drive out what should happen when a customer's payment fails.

** Preventing Tickets Sales to Unpublished Concerts
   In this lesson, we add a new feature test to cover the situation when someone tries to view a concert that hasn't been published yet.

* Limiting Tickets Sales

** Outlining the First Test Case
   In this lesson, we work on writing a test to ensure that customers can't purchase more tickets than are still available

** Adding Tickets to Concerts
   In this lesson, we implement the ability to add tickets to concerts so there are tickets available when a customer tries to purchase.

** Refusing Orders When There Are No More Tickets
   In this lesson, we work on making sure orders are not created when someone tries to purchase more tickets than remain, and ensuring that a customer can't purchase tickets already purchased by another customer.

** Finish the Feature Test
   In this lesson, we get our "cannot purchase more tickets than remain" feature test passing by finishing our controller implementation.

** Cancelling Failed Orders
   In this lesson, we make sure that if a customer's payment fails, we cancel their order.

** Refactoring and Redundant Test Coverage
   In this lesson, we  extract some logic from our Order class to Tickets class, and discuss whether or not it's important to add new test coverage.

** Cleaning Up Our Tests
   Much like production code, test code needs to be refactored and kept healthy and maintainable.
   In this lesson, we go over our existing test suite and look for opportunities to clean it up.

* Returning Order Details
** Asserting Against JSON Response
  In this lesson, we add tests to ensure that we are getting back meaniningfully order information after purchasing tickets, and discuss different strategies for testing JSON response.

** Returning Order Details
   In this lesson, we work on getting our existing feature test passing by driving out an order's JSON representation at the unit level.

** This Design Sucks
   You don't awlays write beautiful code on the first try.
   In this lesson, we talks about three issues with our existing design and why they are worth addressing.

* A Surgical Refactoring
** Persisting the Order Amount
  In this lesson, we work on persisting the order amount to the database, instead of calculating it on the fly based on tickets price and tickets quantitly.

** Removing the Need to Cancel Orders
   In this lesson, we work getting rid of the need to cancel orders when a payment fails by separating the idea of finding tickets from confirming an order.

** Preparing for Extraction
   In this lesson, we work on removing the need to create orders through a concert by removing a redundant relationship.

** Extracting a Named Constructor
   In this lesson, we introduced a named constructor for creating orders from customer details and tickets.

** Precomputing the Order Amount
   In this lesson, we work on removing the need for an order to know how to calculate it's own price so we can eliminlate some duplication in our code.

** Uncovering a New Domain Object
   In this lesson, we walk through a strategy I use to discover new objects in my code, and start driving out a new domain object with tests.

** You Might Not Need a Mocking Framework
   In this lesson, we work on removing the need to migrate the database when testing our simple Reservation class.
   We also talk about different approaches to isolating the Reservation from it's collaborators, and why you might not need a special library to do it.

* Off to the Races
**  Uh Oh, a Race Condition!
   Over the last few lessons we've improved the design of our code significantly, but we've also introduced a race condition.

** Requestception
   In this lesson, we discuss how subrequests work, and how we can use them to help test this race condition.

** Hooking into Charges
   In this lesson, we add a hook to our fake payment gateway to allow us to trigger a nested request.

** Uh Oh, a Segfault!
   In this lesson, we finish wrting our feature test to cover the race condition. But when we run it, we hit a segfault! Let's see if we can diagnose the issue.

** Replicating the Failure at the Unit Level
   In order to get a better understanding of our segfault issue, we try and replicate it at the unit level so we can fix it more easily.

** Reserving Individual Tickets
   To make sure nobody can purchase someone else's tickets while they are still trying to pay, we work on introducing the idea of a ticket being "reserved".

** Reserved Means Reserved
   In this lesson, we work on making sure the rest of the application respects our newly introduced "reserved" status on tickets.

** That Guy Stole My Tickets
   For some reason, person B is getting their name added to tickets that person A paid for! Let's figure out what's going on.

* Hunting for Stale Code

** Cancelling Reservation
   In this lesson, we find a sneaky bug and work towards solving it through an isolated unit test.

** Refactoring Mockes to Spies
   In this lesson, we talk about 3 different ways to create mock objects, as well as how using spies instead of mocks can help keep your tests more organized.

** A Change in Behavior
   Our feature test is still failing because some of our order code has a different understanding of what it means to "releases" tickets.
   In this lesson, we diagnose the issue and update our specification to help us drive out the change in behavior.

** Deleting Stale Tests
   In this lesson, we discuss the importance of high level feature tests, and how they help give use the confidence to delete stale code when confronted with a failing unit test.


* Something Smells in Our Controllers
** Cleaning Up a Loose Variable
   In this lesson, we look to eliminate a loose variable in our controller by adding some additional behavior to our Reservation class, and then spend some time pushing the responsibility for creating reservations inside our Concert class and our of our controller.

** Moving the Email to Reservation
   In this lesson, we notice a long parameter list we'd like to refactor, but in order to do that, we need to tweak how reservations are created so that reservation has knowledge of the customer who is reserving the tickets.

** Refactoring "Long Parameters List" Using "Preserve Whole Object"
   In this lesson, we attempt to refactor the "long parameter list" code smell we noticed in our Order class using the "preserve whole object" refactoring.

** Green with Feature Envy
   Our "preserve whole object" refactoring didn't turn out as nicely as we hoped.
   In this lesson, we look to treat the original problem as a "feature envy" issue instead of a "long parameter list" issue, and see if that leads us to a better solution.

** Avoiding Service Classes with Method Injection
   In this lesson, we notice that we're lacking a single source of truth for the amount we charge the customer and the amount used to create the new order.
   We walk through what it might look like to solve this problem with a service class, and then how we can avoid the service class entirely using method injection.

* Testing-Driving the Real Stripe Adapter

** Generating a Valid Payment Token
   In this lesson we scaffold out an initial test for our StripePaymentGateway and figure out how to generate a valid payment token using Stripe's API.

** Retriving the Last Charge
   In this lesson we use Stripe's API to fetch the most recent charge so we can make assertions about it in our test.

** Making a Successful Charge
   In this lesson we work through the first set of test failures and successfully make a charge to Stripe.

** Dealing with Lingering State
   In this lesson we diagnose why are test is passing after commenting out our implementation, and come up with a new strategy to run our tests with isolated data.

** Don't Mock What You Don't Own
   A commpon miscoception about testing is that you should mock calls to external APIs to avoid the newwork.
   In this lesson, we compare the pros and cons of intergrating with Stripe vs. mocking our calls to Stripe to better understand why shouldn't mock third-party code.

** Using Groups to Skip Intergration Tests
   In this lesson, we use PHPUnit's "group" feature to make it easy to skip our intergration tests when we don't have an internet connection.

** Handling Invalid Payment Tokens
   In this lesson, we add a new test to make sure our StripePaymentGateway behaves as expected when attempting to charge with an invalid payment token.

** The Moment of Truth
   In this lesson, we finally fire up the browser to find out if all of this TDD stuff has really given us a working system.

* Keeping Things Synchronized with Contract Tests

** When Interfaces Aren't Enough
   In this lesson, we identify some of the risks of using fakes, and why it takes more than an interface to make sure multiple implementations stay in sync.

** Refactoring Forward Duplication
   In this lesson, we begin refactoring the tests for our two PaymentGateway implementations towards being identical so we can extract them to a contract test.

** Capturing Charges with Callbacks
   In this lesson, we come up with a strategies for being able to keep track of the total charges made during a test that will work for both implementations for our PaymentGateway interface.

** Making the Tests Identical
   In this lesson, we port the newChargesDuring method over to the FakePaymentGateways, finally leaving us with two identical tests that are ready for extraction.

** Extracting a Contract Test
   In this lesson, we extract the identical PaymentGateway tests into a contract test, shared through a trait.

** Extracting the Failure Case
   In this lesson, we refactor the =charges_with_an_invalid_payment_token_fail= tests to make them identical, and then extract it to our contract tests.



* Upgrading Our Suit to Laravel 5.4

** Upgrading to Laravel 5.4
   In this lesson, we upgrade TicketBeast to Laravel 5.4, and get our tests back to green using =browser-kit-testing= package.

** Removing the BrowserKit Dependency
   In this lesson, we refactor our BrowserKit tests to use Laravel 5.4's testing features, so we can remove our dependency on the compabitility package.

* Viewing Order Confirmations

** Sketching out Order Confirmations
  In this lesson, we begin driving out our test for viewing order confirmations based on a static mockup.

** Driving out the Endpoint
   In this lesson, we figure out th URL structure we want to use to keep order confirmation pages private, and drive out the ability to successfully hit out new endpoint.

** Asserting Against View Data
   In this lesson, we flesh out an initial implementation of our controller, and walk through how to test the data that is bound to a view without asserting against the rendered HTML.

** Extracting a Finder Method
   In this lesson, we refactor some Eloquent calls in our controller to a dedicated finder method, and discuss when it's important to add new tests while refactoring and when it's not.

** Making Static Data Real
   In this lesson, we work through using tests to replace some of the hard coded data in our mockup with real data that's attached to our order.

** Deciding What to Test in a View
   In this lesson, we spend some time discussing what you need to take into consideraction when deciding what data is important to test in a renderd view.

** Decoupling Data from Presentation

* Generating Confirmation Numbers

** Fixing the Test Suit
   In this lesson, we get our test suit back to green by temporarily making some of our new columns nullable, and discuss adding a test to ensure confirmation numbers are generated for new orders.

** Stubbling the Interface
   In this lesson, we decide we want to able to stub how order confirmation numbres are gerenated for our high level feature test, and use that insight to design an interface where we can encapsulate that logic.

** Updating Our Unit Tests
   In this lesson, we update one of our =Order= unit tests to make use of the factory we added previously, and make sure that orders include their confirmation numbers when we render them as JSON.

** Confirmation Number Characteristics
   In this lesson, we discuss the what we want our confirmation numbers ultimately look like and why.

** Testing the Confirmation Number Format
   In this lesson, we use the characteristics we identified previously to specify how our confirmation numbers should look with a set of unit tests, and work on getting them to pass.

** Ensuring Uniqueness
   In this lesson, we come up with a strategy to force ourselves away from our slimed implementation by testing that each confirmation number is unique.

** Recatoring to a Facade
   In this lesson, we wire up our =RandomOrderConfirmationNumberGenernator= to be the default implementation we use in our application, and make use of Laravel's =Facade= to replace our explict use of Laravel's container in our =order= class with something more expressive.

* Storing the Last Four Card Digists

** Prompting Charges to Objects
   In this lesson, we introduce a new =Charge= object to carry meta data about purchases, such as the last four digits of the card used. We drive out this charge in our =FakePaymentGateway= first through changes to our =PaymentGatewayContractTests=.

** Leveraging Our Contract Tests
   In this lesson, we use our updated contract tests to update the behavior of our StripePaymentGateway to keep it synchronized with our fake.

** Storing Charge Details with Orders
   In this lesson, we update our =OrderTest= to account for creating orders using =Charges= instead of plain amounts, and use that test to drive out the implementation in =order=.

** Deleting More Stale Code
   In this lesson, we notice that changing how =orders= created reveals some lingering old design decisions that are triggering test failures. We work through removing the stale code, and updating any tests we need to keep to no longer rely on the code we want to remove.


* Assigining Ticket Codes

** Feature Test and JSON Updates
   In this lesson, we come up with approach for driving out the generation of ticket codes from the outside in, and make some tweaks to the JSON representation of a completed order.

** Claiming Tickets When Creating Orders
   In this lesson, we decide when ticket codes should be generated, and rework and existing test to use mock expectations to prepare for our implementation.

** Assigining Codes When Claiming Tickets
   In this lesson, we add a new test for the new =claimFor= method in our =Ticket= class, and drive out them implementation.

** The Birthday Problem
   In this lesson, we talk about the birthday problem and the implications it has own how we generate ticket codes.
   We also play with the Hashids library to get an understanding of how we could use it to encode ticket IDs.

** Intergrating Hashids
   In this lesson, we drive out our =HashidsTicketCodeGenerator=, making sure that ticket codes are generated in the format we expect.

** Dealing with Out of Sync Mock
   Uh oh! One of our expectations is no longer in sync with the real implementation.
   In this lesson, we use an underappreciated Mockery feature to detect broken mockes, and get things working properly again.

** Writing It Together
   In this lesson, we bubble back up to our initial feature test and try to get it passing.
   We cover how to return multiple values from a Mockery stub, and wire up our real =HashidsTicketCodeGenerator= in the IOC container to get the test suit back to green.

** Ready to Demo
   In this short lesson, we make a small tweak to our =TicketCheckout= Vue component and finally walk through the entire purchasing flow from start to finish.

* Emailing Order Confirmations

**  Using a Fake to Intercept Email
  In this lesson, we use Laravel's =Mail Fake= to test sending an order confirmation email whenever someone purchases tickets.

** Testing Mailable Contents
   In this lesson, we come up with a way to render mailables as HTML so we can assert against their content.

** Cleanup and Demo
   In this lesson, we configure Mailtrap so we can test our order confirmation email flow in the browser.

* Logging in with Dusk

** Testing the Login Endpoint
   The next thing we'd like to build is the ability for promoters to add new concerts, but before we can do that, we need to give them a way to log in to the application.
   In this lesson, we drive out our initial =/login= endpoint.

** Should You TDD Simple Templates?
   In the last lesson we drove out the login endpoint, but we still don't have an actual login form.
   Is this something we should try to build with TDD, or is there a better approach?

** Namespacing Our Test Suite
   Before we get started with Laravel Dusk, let's update our test folder structure to match which ships with Laravel 5.4 to make it a little easier to integrate.

** Getting Started with Laravel Dusk
   In this lesson, we install and configure =Laravel Dusk=, talk about some gotchas you might run into if you're not approaching it with the right mindset, and get a basic example browser test running.

** QA Testing the Login Flow
   In this lesson, we use Dusk to drive out a browser test for our login form to make sure we have regression coverage.

* Adding New Concerts

** Preventing Guests from Adding Concerts
   In this lesson, we walk through some behind-scenes changes made since the last lesson and work on adding some basic authorization tests.

** Adding a Valid Concert
   In this lesson we drive out the ability to add new concerts and make sure only promoters can access this endpoint.

** Validations and Redirects
   In this lesson we drive out our first validation rule for the concert form, and look at a useful trick for making assertions about =redirect()->back()= behavior.
** Converting Empty Strings to Null
   In this lesson we add a test to prove that concert subtitles are optional, and active some new middleware from Laravel 5.4 to simplify thet task.

** Reducing Noise with Form Factories
   In this lesson we identify a lot of duplication in our validation tests and use a technique similar to model factires to clean up the noise.

** Connecting Promoters to Concerts
   Up until now we've being operating under this assumption that we'd add concerts manually on a promoter's behalf.
   Now that promoters can add concerts themselves, we need to make sure we are tracking who adds each concert so we know who to transfer the ticket money to.

** Autopublishing New Concerts
   In one of the earlist lessons in the course, we added some functionality to make sure that only published concerts were visible in the browser.
   Since we don't have ability to publish new concerts from the UI yet, let's at least make sure that new concerts are published by default until we get to that feature.
