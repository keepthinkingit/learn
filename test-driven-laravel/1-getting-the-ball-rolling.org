* Getting the Ball Rolling
** What Do We Build First
   First of all, welcome to Test-Driven Laravel!
   To get things started, let's talk a bit about the app we are going to build, and figure out where we should start.
   [[~/Documents/tutorials/test-driven-laravel/1-getting-the-ball-rolling/1-what-do-we-build-first.mp4][1-what-do-we-build-first.mp4]]
** Sketching out Our First Test
   In this lesson, we scaffold out a new application and start sketching out the first test.

** Getting to Green
   In this lesson, we use TDD to scaffold out a lot of the boiler plate in the application and get our first test passing.

** Unit Testing Presentation Logic
   In this lesson, we drive out some presentation helpers via unit tests to extract some logic from our view.

** Refactoring For Speed
   In this lesson, we finish extracting some presentation helpers, then refactor our tests to run without using the database to keep thing fast.

** Hiding Unpublished Concerts
   In this lesson, we introduce the idea of "published" and "unpublished" concerts, and hide unpblished concerts from visitors to the site.

** Testing Query Scopes
   In this lesson, we extract some query logic to a custom scope and ensure that it's covered by our tests.

** Factory States
   In this lesson, we abstract some details about makes a concert "published" from our tests by encapsulating them in a factory state.

* Purchasing Concert Tickets
** Intro
   In this lesson, we talk about getting started with the "Purchasing Concert Tickets" feature that we're going to implement next.

** Browser Testing vs Endpoint Testing
   In this lesson, we talk about the trade-offs involved in testing through the browser vs. testing endpoint directly, and why you might choose one option over the other.

** Outlining the First Purchasing Test
   In this lesson, we design our initial "customer can purchase concert tickets" test.

** Faking the Payment Gateway
   In this lesson, we create a fake implementation of our payment gateway to avoid hitting Stripe during our intergration tests.

** Adding Tickets to Orders
   In this lesson, we work on creating tickets and attaching them to orders when a customer make a purchase.

** Encapsulating Relactionship Logic in the Model
   In this lesson, we work on refactoring some of our controller code and pushing some logic into the model.

** Getting Started with Validation Testing
   In this lesson, we work on testing and implementing some request validation rules.

** Reducing Duplication with Custom Assertion
   In this lesson, we abstract some commonly paired assertions behind a custom assertion with a more expressive name.

** Handling Failed Charges
   In this lesson, we drive out what should happen when a customer's payment fails.

** Preventing Tickets Sales to Unpublished Concerts
   In this lesson, we add a new feature test to cover the situation when someone tries to view a concert that hasn't been published yet.

* Limiting Tickets Sales

** Outlining the First Test Case
   In this lesson, we work on writing a test to ensure that customers can't purchase more tickets than are still available

** Adding Tickets to Concerts
   In this lesson, we implement the ability to add tickets to concerts so there are tickets available when a customer tries to purchase.

** Refusing Orders When There Are No More Tickets
   In this lesson, we work on making sure orders are not created when someone tries to purchase more tickets than remain, and ensuring that a customer can't purchase tickets already purchased by another customer.

** Finish the Feature Test
   In this lesson, we get our "cannot purchase more tickets than remain" feature test passing by finishing our controller implementation.

** Cancelling Failed Orders
   In this lesson, we make sure that if a customer's payment fails, we cancel their order.

** Refactoring and Redundant Test Coverage
   In this lesson, we  extract some logic from our Order class to Tickets class, and discuss whether or not it's important to add new test coverage.

** Cleaning Up Our Tests
   Much like production code, test code needs to be refactored and kept healthy and maintainable.
   In this lesson, we go over our existing test suite and look for opportunities to clean it up.

* Returning Order Details
** Asserting Against JSON Response
  In this lesson, we add tests to ensure that we are getting back meaniningfully order information after purchasing tickets, and discuss different strategies for testing JSON response.

** Returning Order Details
   In this lesson, we work on getting our existing feature test passing by driving out an order's JSON representation at the unit level.

** This Design Sucks
   You don't awlays write beautiful code on the first try.
   In this lesson, we talks about three issues with our existing design and why they are worth addressing.

* A Surgical Refactoring
** Persisting the Order Amount
  In this lesson, we work on persisting the order amount to the database, instead of calculating it on the fly based on tickets price and tickets quantitly.

** Removing the Need to Cancel Orders
   In this lesson, we work getting rid of the need to cancel orders when a payment fails by separating the idea of finding tickets from confirming an order.

** Preparing for Extraction
   In this lesson, we work on removing the need to create orders through a concert by removing a redundant relationship.

** Extracting a Named Constructor
   In this lesson, we introduced a named constructor for creating orders from customer details and tickets.

** Precomputing the Order Amount
   In this lesson, we work on removing the need for an order to know how to calculate it's own price so we can eliminlate some duplication in our code.

** Uncovering a New Domain Object
   In this lesson, we walk through a strategy I use to discover new objects in my code, and start driving out a new domain object with tests.

** You Might Not Need a Mocking Framework
   In this lesson, we work on removing the need to migrate the database when testing our simple Reservation class.
   We also talk about different approaches to isolating the Reservation from it's collaborators, and why you might not need a special library to do it.

* Off to the Races
**  Uh Oh, a Race Condition!
   Over the last few lessons we've improved the design of our code significantly, but we've also introduced a race condition.

** Requestception
   In this lesson, we discuss how subrequests work, and how we can use them to help test this race condition.

** Hooking into Charges
   In this lesson, we add a hook to our fake payment gateway to allow us to trigger a nested request.

** Uh Oh, a Segfault!
   In this lesson, we finish wrting our feature test to cover the race condition. But when we run it, we hit a segfault! Let's see if we can diagnose the issue.

** Replicating the Failure at the Unit Level
   In order to get a better understanding of our segfault issue, we try and replicate it at the unit level so we can fix it more easily.

** Reserving Individual Tickets
   To make sure nobody can purchase someone else's tickets while they are still trying to pay, we work on introducing the idea of a ticket being "reserved".

** Reserved Means Reserved
   In this lesson, we work on making sure the rest of the application respects our newly introduced "reserved" status on tickets.

** That Guy Stole My Tickets
   For some reason, person B is getting their name added to tickets that person A paid for! Let's figure out what's going on.
